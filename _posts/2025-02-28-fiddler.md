---
layout: distill
title: "Fiddler Puzzle: How Many Rabbits Can You Pull out of a Hat?"
description: My solution to this week's Fiddler on the Proof Puzzle
giscus_comments: true
date: 2025-03-01 00:00:01
published: true
tags: programming
authors:
  - name: Connor Colombe
    url: "https://ccolombe12.github.io/"
    affiliations:
      name: ORIE, UT Austin
bibliography: 

# Optionally, you can add a table of contents to your post.
# NOTES:
#   - make sure that TOC names match the actual section names
#     for hyperlinks within the post to work correctly.
#   - we may want to automate TOC generation in the future using
#     jekyll-toc plugin (https://github.com/toshimaru/jekyll-toc).
toc:
  - name: Problem Statement
    # if a section has subsections, you can add them as follows:
    # subsections:
    #   - name: Example Child Subsection 1
    #   - name: Example Child Subsection 2
  - name: Solution
  

---

## How Many Rabbits Can You Pull Out of a Hat?

I found a new source of puzzles: the excellent Substack page [The Fiddler on the Proof](https://thefiddler.substack.com) run by Zach Wissner-Gross. This week's puzzle is paraphrased as follows: 
<blockquote>Suppose I have a hat with $3n$ small toy rabbits: $n$ are red, $n$ are green, and $n$ are blue. I shuffle the rabbits around and randomly draw them out one at a time without replacement (i.e., once I draw a rabbit out, I never put it back in again).

Your job is to guess the color of each rabbit I draw. For each guess, you know the history of the rabbits already drawn. So if we’re down to the final rabbit in the hat, you should be able to predict its color with certainty.

Every time you correctly predict the color of the rabbit I draw, you earn a point. If you play optimally (i.e., to maximize your expected points), how many points can you expect to earn on average?
</blockquote>
## Solution

We can solve this using **Dynamic Programming**! We represent the current state as a tuple $(r, g, b)$, where $r, g,$ and $b$ denote the number of rabbits of each color remaining in the hat. Let $J(r, g, b)$ be the maximum expected score starting from state $(r, g, b)$. Our goal is to determine $J(n, n, n)$.

### Base Cases

- If there are no rabbits left, i.e., $(0, 0, 0)$, then there are no points left to obtain:
  $$
  J(0, 0, 0) = 0.
  $$
- If any of $r, g,$ or $b$ are negative, we define:
  $$
  J(r, g, b) = 0, \quad \text{for any } r < 0, g < 0, \text{ or } b < 0.
  $$
  While negative counts don't have a physical interpretation, this condition simplifies our recurrence relation.

### Recurrence Relation

For a general state where $r, g, b \geq 0$ and at least one of them is positive, we determine the best guess for the next rabbit's color.

- The probability of drawing a red rabbit is $ P_r = \frac{r}{r + g + b} $.
- The probability of drawing a green rabbit is $ P_g = \frac{g}{r + g + b} $.
- The probability of drawing a blue rabbit is $ P_b = \frac{b}{r + g + b} $.

Given these, the expected score from guessing each color is:

$$
J\left(r, g, b \mid \text{guess red}\right) = P_r (1 + J(r - 1, g, b)) + P_g J(r, g - 1, b) + P_b J(r, g, b - 1),
$$
$$
J\left(r, g, b \mid \text{guess green}\right) = P_r J(r - 1, g, b) + P_g (1 + J(r, g - 1, b)) + P_b J(r, g, b - 1),
$$
$$
J \left(r, g, b \mid \text{guess blue}\right) = P_r J(r - 1, g, b) + P_g J(r, g - 1, b) + P_b (1 + J(r, g, b - 1)).
$$

To find the optimal expected score, we take the maximum over these three choices:

$$
J(r, g, b) = \max \{ J(r, g, b \mid \text{guess red}), J(r, g, b \mid \text{guess green}), J(r, g, b \mid \text{guess blue}) \}.
$$

The optimal guess is the color that achieves this maximum.

### Implementation

Now that we have a recursive formulation, we can efficiently compute $J(r, g, b)$ using dynamic programming. Let’s code this up in Python!

```python
from functools import cache
import numpy as np
import matplotlib.pyplot as plt
from fractions import Fraction

@cache
def max_point(r, g, b):
""" Returns the maximum expected score under optimal play from the state
(r, g, b) """
    # Base Cases
    if r < 0 or g < 0 or b < 0:
        return 0
    elif r == 0 and g == 0 and b == 0:
        return 0
    # Main recurrence Case 
    if r > 0 or g > 0 or b > 0:
        total_rabbits = r + g + b
        Pr, Pb, Pg = r / total_rabbits, b / total_rabbits, g / total_rabbits
        
        guess_red = (Pr * (1 + max_point(r - 1, g, b)) +  
            Pg * max_point(r, g - 1, b) +
            Pb * max_point(r, g, b - 1))
        
        guess_green = (Pg * (1 + max_point(r, g-1, b)) +
                       Pr * max_point(r - 1, g, b) +
                       Pb * max_point(r, g, b - 1))
                       
        guess_blue = (Pb * (1 + max_point(r, g, b - 1)) +
                      Pr * max_point(r - 1, g, b) +
                      Pg * max_point(r, g - 1, b))
        
        return max(guess_green, guess_red, guess_blue)

def optimal_score(n):
    return max_point(n, n, n)
```



<d-code block language="python">
  def max_point(r, g, b):
""" Returns the maximum expected score under optimal play from the state
(r, g, b) """
    # Base Cases
    if r < 0 or g < 0 or b < 0:
        return 0
    elif r == 0 and g == 0 and b == 0:
        return 0
    # Main recurrence Case 
    if r > 0 or g > 0 or b > 0:
        total_rabbits = r + g + b
        Pr, Pb, Pg = r / total_rabbits, b / total_rabbits, g / total_rabbits
        
        guess_red = (Pr * (1 + max_point(r - 1, g, b)) +  
            Pg * max_point(r, g - 1, b) +
            Pb * max_point(r, g, b - 1))
        
        guess_green = (Pg * (1 + max_point(r, g-1, b)) +
                       Pr * max_point(r - 1, g, b) +
                       Pb * max_point(r, g, b - 1))
                       
        guess_blue = (Pb * (1 + max_point(r, g, b - 1)) +
                      Pr * max_point(r - 1, g, b) +
                      Pg * max_point(r, g - 1, b))
        
        return max(guess_green, guess_red, guess_blue)

  def optimal_score(n):
    return max_point(n, n, n)
</d-code>

{% highlight javascript %}
var x = 25;
function(x) {
return x \* x;
}
{% endhighlight %}


