<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://ccolombe12.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ccolombe12.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2025-03-15T22:28:00+00:00</updated><id>https://ccolombe12.github.io/feed.xml</id><title type="html">blank</title><subtitle>The academic wepage of Connor Colombe
</subtitle><entry><title type="html">A Pi-Day Puzzle</title><link href="https://ccolombe12.github.io/blog/2025/Pi_day/" rel="alternate" type="text/html" title="A Pi-Day Puzzle" /><published>2025-03-14T00:00:00+00:00</published><updated>2025-03-14T00:00:00+00:00</updated><id>https://ccolombe12.github.io/blog/2025/Pi_day</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2025/Pi_day/"><![CDATA[<p>This week’s <a href="https://thefiddler.substack.com">The Fiddler on the Proof</a> puzzle is paraphrased as follows:</p>

<blockquote>
  <p>You are planning a picnic on the remote tropical island of \(\pi\)-land. The island’s shape is a perfect semi-disk with two beaches, as illustrated below. We have <strong>Semicircular Beach</strong> (along the northern semicircular edge of the disk) and <strong>Diametric Beach</strong> (along the southern diameter of the disk).</p>

  <p><strong>Part 1:</strong><br />
<em>If you pick a random spot on \(\pi\)-land for your picnic, what is the probability that it will be closer to Diametric Beach than to Semicircular Beach?</em></p>

  <p><strong>Part 2:</strong><br />
<em>Given the radius of \(\pi\)-land is 1, on average, what will be the expected shortest distance to shore?</em></p>
</blockquote>

<figure>
    <img src="/assets/img/blog_images/2025-03-14-Pi_day/Pi_island.png" alt="Illustration of the island" width="80%" style="display: block; margin: auto;" />
    <figcaption style="text-align: center;">Figure 1: The island.</figcaption>
</figure>

<hr />

<h2 id="solution">Solution</h2>

<h3 id="part-1">Part 1</h3>

<p>The immediate intuition is that the set of points closer to the Diametric Beach than the Semicircular Beach should form a well-defined geometric region. If we can determine that region, denoted \(D\), the desired probability is simply the area of that region divided by the area of the entire semicircle.</p>

<p>Let the island’s radius be 1, its center be at \((0, 0)\), and denote the points on the island by the region \(C\). Consider a point \((x, y)\) on the island, which beach is it closer to? The <strong>distance to Diametric Beach</strong> is just its \(y\)-coordinate. What about the <strong>distance to Semicircular Beach</strong>?</p>

<p>The shortest path from \((x, y)\) to Semicircular Beach is along the radial line through \((0,0)\) and \((x,y)\).<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup> This means the shortest distance to the Semicircular Beach is given by:</p>

\[1 - \sqrt{x^2 + y^2}\]

<p>Therefore, for a point to be <strong>closer to the Diametric Beach than the Semicircular Beach</strong>, the following inequality must hold:</p>

\[y \leq 1 - \sqrt{x^2 + y^2}\]

<p>Rearranging:</p>

\[y \leq \frac{1 - x^2}{2}\]

<p>Thus, the region \(D\) of points closer to the Diametric Beach than the Semicircular Beach is:</p>

\[D = \left\{ (x, y) \in C \mid y \leq \frac{1 - x^2}{2} \right\}.\]

<p>This region is depicted below:</p>

<figure>
    <img src="/assets/img/blog_images/2025-03-14-Pi_day/semicircle_plot.png" alt="Geometric region solution" width="80%" style="display: block; margin: auto;" />
    <figcaption style="text-align: center;">Figure 2: The region closer to the Diameter Beach than the Semicircular Beach (Blue).</figcaption>
</figure>

<p>Now, we compute the area of this region using integration:</p>

\[\text{Area}(D)  = \int_{-1}^1 \int_0^{\frac{1-x^2}{2}} dy \; dx = \frac{2}{3}.\]

<p>Since the total area of the semicircle is \(\frac{\pi}{2}\), the <strong>probability of being closer to the Diametric Beach is</strong>:</p>

\[\boxed{\frac{\text{Area}(D)}{\text{Area}(C)} = \frac{2/3}{\pi / 2} = \frac{4}{3\pi}}\]

<hr />

<h3 id="part-2">Part 2</h3>

<p>We’ve already done most of the heavy lifting in part 1)! Define \(L\) as the random variable representing the shortest distance to a beach. At a given point \((x, y) \in C\):</p>

<ul>
  <li>If \((x, y) \in D\), the shortest distance is \(y\).</li>
  <li>If \((x, y) \in D^c\), the shortest distance is \(1 - \sqrt{x^2 + y^2}\).</li>
</ul>

<p>Breaking up the expectation integral into two parts and solving yields:</p>

\[\begin{align*}
\mathbb{E}[L] &amp; = \frac{1}{\pi /2} \int_C \min\left(y, 1 - \sqrt{x^2 + y^2}\right) dy \; dx \\ 
&amp; = \frac{1}{\pi/2} \int_D y \; dy \; dx + \frac{1}{\pi/2} \int_{D^c} \left(1 - \sqrt{x^2 + y^2}\right) dy \; dx\\ 
&amp; = \frac{1}{\pi/2} \int_{-1}^1\int_0^{\frac{1-x^2}{2}} y \; dy \; dx + \frac{1}{\pi/2} \int_{-1}^1\int_{\frac{1-x^2}{2}}^{\sqrt{1 - x^2}}1 - \sqrt{x^2 + y^2}  \; dy \; dx\\
 &amp; = \boxed{\frac{3 \pi - 4}{9 \pi }}
\end{align*}\]

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>Can you prove this? <em>Hint: Use the triangle inequality.</em> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Connor Colombe</name></author><category term="math" /><summary type="html"><![CDATA[My solution to this week's Fiddler on the Proof Puzzle]]></summary></entry><entry><title type="html">How Many Rabbits Can You Pull out of a Hat?</title><link href="https://ccolombe12.github.io/blog/2025/fiddler/" rel="alternate" type="text/html" title="How Many Rabbits Can You Pull out of a Hat?" /><published>2025-03-01T00:00:00+00:00</published><updated>2025-03-01T00:00:00+00:00</updated><id>https://ccolombe12.github.io/blog/2025/fiddler</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2025/fiddler/"><![CDATA[<p>I found a new source of puzzles: the excellent Substack page <a href="https://thefiddler.substack.com">The Fiddler on the Proof</a> run by Zach Wissner-Gross. This week’s puzzle is paraphrased as follows:</p>

<blockquote>
  <p>Suppose I have a hat with \(3n\) small toy rabbits: \(n\) are red, \(n\) are green, and \(n\) are blue. I shuffle the rabbits around and randomly draw them out one at a time without replacement (i.e., once I draw a rabbit out, I never put it back in again).</p>

  <p>Your job is to guess the color of each rabbit I draw. For each guess, you know the history of the rabbits already drawn. So if we’re down to the final rabbit in the hat, you should be able to predict its color with certainty.</p>

  <p>Every time you correctly predict the color of the rabbit I draw, you earn a point. If you play optimally (i.e., to maximize your expected points), <strong>how many points can you expect to earn on average?</strong></p>
</blockquote>

<h2 id="solution">Solution</h2>

<p>We can solve this using <a href="https://en.wikipedia.org/wiki/Dynamic_programming">Dynamic Programming</a>! We represent the current state as a tuple \((r, g, b)\), where \(r, g,\) and \(b\) denote the number of rabbits of each color remaining in the hat. Let \(J(r, g, b)\) be the maximum expected score starting from state \((r, g, b)\). Our goal is to determine \(J(n, n, n)\). We can solve for \(J(n, n, n)\) by developing a <strong>recurrence relation</strong> on the current state. We begin with the base cases.</p>

<h3 id="base-cases">Base Cases</h3>

<ul>
  <li>If there are no rabbits left, i.e., we are at state \((0, 0, 0)\), then there are zero points left to obtain, implying
\(J(0, 0, 0) = 0.\)</li>
  <li>If any of \(r, g,\) or \(b\) are negative, we define:
\(J\left(r, g, b \right) = 0, \; \text{if any } r &lt; 0, g &lt; 0, \text{or } b &lt; 0.\)
While negative rabbit counts don’t have any physical interpretation, this condition will allow us to greatly simplify our recurrence relation.</li>
</ul>

<h3 id="recurrence-relation">Recurrence Relation</h3>

<p>For a general state where \(r, g, b \geq 0\) and at <em>least one of them is positive</em>, we can determine the expected points-maximizing guess for the next rabbit’s color by considering each option and selecting the best one. The probabilities for the next color of rabbit drawn are:</p>

<ul>
  <li>The probability of drawing a red rabbit \(P_r = \frac{r}{r + g + b}\).</li>
  <li>The probability of drawing a green rabbit \(P_g = \frac{g}{r + g + b}\).</li>
  <li>The probability of drawing a blue rabbit \(P_b = \frac{b}{r + g + b}\).</li>
</ul>

<p>Given these, the expected scores from guessing each color are:</p>

<p>\(J\left(r, g, b \mid \text{guess red}\right) = P_r \cdot (1 + J(r - 1, g, b)) + P_g\cdot J(r, g - 1, b) + P_b\cdot J(r, g, b - 1),\)
\(J\left(r, g, b \mid \text{guess green}\right) = P_r\cdot J(r - 1, g, b) + P_g\cdot (1 + J(r, g - 1, b)) + P_b\cdot J(r, g, b - 1),\)
\(J \left(r, g, b \mid \text{guess blue}\right) = P_r\cdot J(r - 1, g, b) + P_g\cdot J(r, g - 1, b) + P_b\cdot (1 + J(r, g, b - 1)).\)</p>

<p>To find the optimal expected score at state \((r, g, b)\), we take the maximum over these three choices.</p>

\[\boxed{J\left(r, g, b\right) = \max \left\{ J\left(r, g, b \mid \text{guess red}\right), J\left(r, g, b \mid \text{guess green}\right), J\left(r, g, b \mid \text{guess blue}\right) \right\}}.\]

<p>The optimal guess is the color that achieves this maximum.</p>

<h3 id="implementation">Implementation</h3>

<p>Now that we have a recursive formulation, we can efficiently compute \(J(r, g, b)\) using dynamic programming. Let’s code this up in Python<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">functools</span> <span class="kn">import</span> <span class="n">cache</span>

<span class="nd">@cache</span>
<span class="k">def</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="sh">"""</span><span class="s"> Returns the maximum expected score under optimal play from the state
(r, g, b) </span><span class="sh">"""</span>
    <span class="c1"># Base Cases
</span>    <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">g</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">g</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="c1"># Main recurrence Case 
</span>    <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">g</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">total_rabbits</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">g</span> <span class="o">+</span> <span class="n">b</span>
        <span class="n">Pr</span><span class="p">,</span> <span class="n">Pb</span><span class="p">,</span> <span class="n">Pg</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">total_rabbits</span><span class="p">,</span> <span class="n">b</span> <span class="o">/</span> <span class="n">total_rabbits</span><span class="p">,</span> <span class="n">g</span> <span class="o">/</span> <span class="n">total_rabbits</span>
        
        <span class="n">guess_red</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pr</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="o">+</span>  
            <span class="n">Pg</span> <span class="o">*</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">+</span>
            <span class="n">Pb</span> <span class="o">*</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        
        <span class="n">guess_green</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pg</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="o">+</span>
            <span class="n">Pr</span> <span class="o">*</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">+</span>
            <span class="n">Pb</span> <span class="o">*</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                       
        <span class="n">guess_blue</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pb</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span>
            <span class="n">Pr</span> <span class="o">*</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">+</span>
            <span class="n">Pg</span> <span class="o">*</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">guess_green</span><span class="p">,</span> <span class="n">guess_red</span><span class="p">,</span> <span class="n">guess_blue</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">optimal_score</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="sh">"""</span><span class="s"> The value of J(n, n n) and the answer to our puzzle. </span><span class="sh">"""</span>
    <span class="k">return</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</code></pre></div></div>

<p>Now, if we plot the value of \(J(n, n, n)\) as a function of \(n\), we obtain Figure 1. Here we see that under the optimal guessing strategy, the expected score seems to grow roughly like \(\sim \frac{n}{3}\). In fact, we can actually note that \(\frac{n}{3}\) is a lower bound on the optimal expected score because it can be <em>obtained with certainty</em> by choosing one color of rabbit and guessing that color each turn until the game ends. We call this naive strategy the “stubborn guessing” strategy (since you refuse to change your guess each turn).</p>

<figure>
    <img src="/assets/img/blog_images/2025-02-28-rabbits/optimal_rabbits.png" alt="Max Rabbits Optimal Score" width="80%" style="display: block; margin: auto;" />
    <figcaption style="text-align: center;">Figure 1: Maximum number of points possible with optimal rabbit selection.</figcaption>
</figure>

<p>We can see that our optimal strategy does outperform the stubborn guessing strategy, but not by too much!</p>

<p>Okay, we have found a way to compute the expected number of points we can score under the optimal guessing strategy, but <strong>what actually is the optimal guessing strategy?</strong>. By recording the optimal guess at each step in our recursion, we can observe the optimal strategy has a simple form:</p>

<blockquote>
  <p><em>At any given state, guess a color that has the most rabbits remaining in the hat</em>.</p>
</blockquote>

<p>This makes sense intuitively, and this simple rule provides us with the best heuristic for maximizing our expected score.</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>Instead of building the DP table explicitly, we use the <code class="language-plaintext highlighter-rouge">cache</code> tool from the <code class="language-plaintext highlighter-rouge">functools</code> library. It’s one of my favorite Python tools! <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Connor Colombe</name></author><category term="programming," /><category term="math" /><summary type="html"><![CDATA[My solution to this week's Fiddler on the Proof Puzzle]]></summary></entry><entry><title type="html">Leetcode Milestone</title><link href="https://ccolombe12.github.io/blog/2024/CP_intro/" rel="alternate" type="text/html" title="Leetcode Milestone" /><published>2024-06-17T00:00:01+00:00</published><updated>2024-06-17T00:00:01+00:00</updated><id>https://ccolombe12.github.io/blog/2024/CP_intro</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2024/CP_intro/"><![CDATA[<h2 id="my-journey-to-start-competitive-programming">My journey to start competitive programming</h2>

<p>It’s no secret that I love to think about and work on math/programming puzzles. Over the past several months I have decided to begin a new hobby: Competitive programming! Not only will this keep me sharp for my upcoming job search post grad school, but it is a great way to continue to bolster my problem solving skills and keep fresh the algorithm design skills that I learned during my time at UTD.</p>

<p>My favorite resources for finding problems to work on are: <a href="https://leetcode.com/">Leetcode</a> (a very popular site for interview style programming problems), <a href="https://open.kattis.com/">Kattis</a> (an online problem archive of problems that have been asked in programming contests around the world), and <a href="https://codeforces.com/">Codeforces</a> (another very popular website that hosts high-quality contests). I have been regularly competing in the weekly Leetcode contests and learning a lot in doing so! I plan to reach around 500 problems in Leetcode and achieve a 1900+ rating and then switch to Codeforces since I have heard the problems are more interesting and more mathematical (woo!). I recently broke into the  “knight” level in the Leetcode contests which is currently for those  the top ~ 6% in overall contest performance! You can check out my current contest rating and activity <a href="https://leetcode.com/u/ccolombe12">here</a>!</p>

<h3><figure>
  <center>
  <img src="/assets/img/blog_images/LC_post/LC_Knight.png" width="80%" style="display: block; margin: auto;" />
  </center>

</figure></h3>]]></content><author><name>Connor Colombe</name></author><category term="programming" /><summary type="html"><![CDATA[My journey to start competitive programming]]></summary></entry><entry><title type="html">Jane Street Puzzle August 2024</title><link href="https://ccolombe12.github.io/blog/2024/JS_tree/" rel="alternate" type="text/html" title="Jane Street Puzzle August 2024" /><published>2024-06-17T00:00:01+00:00</published><updated>2024-06-17T00:00:01+00:00</updated><id>https://ccolombe12.github.io/blog/2024/JS_tree</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2024/JS_tree/"><![CDATA[<h1 id="tree-edge-triage">Tree-Edge Triage</h1>

<p>It has become a hobby of mine to work on the monthly <a href="https://www.janestreet.com/puzzles/current-puzzle/">Jane Street Puzzle</a>. They usually pose some interesting math or programming problem and I have learned a lot from solving them. Last month’s puzzle was a game played on an infinite binary tree with a surprising result! The problem is as follows:</p>

<h1 id="problem-statement">Problem Statement</h1>
<blockquote>
  <p>Aaron and Beren are playing a game on an infinite complete binary tree. At the beginning of the game, every edge of the tree is independently labeled \(A\) with probability \(p\) and \(B\) otherwise. Both players are able to inspect all of these labels. Then, starting with Aaron at the root of the tree, the players alternate turns moving a shared token down the tree (each turn the active player selects from the two descendants of the current node and moves the token along the edge to that node). If the token ever traverses an edge labeled B, Beren wins the game. Otherwise, Aaron wins.</p>

  <p>An example game is in the picture below: after the labeling, Aaron chooses to go left to avoid immediate defeat, but after Beren goes right Aaron is doomed to choose one of two B paths and Beren wins.</p>

  <p><strong>What is the infimum of the set of all probabilities \(p\) for which Aaron has a nonzero probability of winning the game?</strong> Give your answer in exact terms.</p>
</blockquote>

<h3><figure>
  <center>
  <img src="/assets/img/blog_images/JS_Aug_24/ps.png" style="width: 40vw; min-width: 330px;" zoomable="true" />
  </center>
</figure></h3>
<h1 id="solution">Solution</h1>

<p>The intuition behind my approach was to use the <strong>symmetry</strong> of an infinite binary tree. Once you move along an edge to a given node, you are once again faced with an infinite binary tree and <em>it’s like you started from the beginning again</em>. By that logic, it is sufficient to analyze the optimal strategy for the first two levels and we can let recursion handle the rest.</p>

<p>Suppose we are considering what Aaron should do on a given turn. On every \(A\) (odd) turn, Aaron wins if and only if the current node has at least one \(A\) edge out of it that leads to a node with two \(A\) edges and each of these edges has a winning \(A\) path out of it.</p>

<p>We can write this using a recurrence relation. Let \(Q_A\) be the probability that, on an \(A\) turn, \(A\) can win from the current node from it. Similarly, let \(Q_B\) be the probability that at our current node on a \(B\) turn, it is one from which \(A\) <em>will</em> win.</p>

<p>Using this notation, we can develop our recurrence relation as:</p>

\[\begin{align}
Q_A &amp; = p^2(\underbrace{Q_B^2 + 2Q_B(1-Q_B)}_{\text{Pr at least one winning path out}}) + 2p(1-p)Q_B \\
Q_B &amp; = p^2 Q_A^2.
\end{align}\]

<p>The fist equation represents the cases where we are on Aaron’s turn and either:</p>

<ul>
  <li>both of the edges out of our current node are labeled \(A\) and Aaron can win from at least one of the children nodes</li>
  <li>There is only one \(A\) edge out of the current node and Aaron can win from the node it leads to.</li>
</ul>

<p>The second equation represents the case where we are on Beren’s turn and:</p>

<ul>
  <li>Both of the edges out of the current node are labeled \(A\) and lead to nodes at which Aaron wins.</li>
</ul>

<p>Plugging in the latter equation into the former yields the equation for \(Q_A\) in terms of \(p\)</p>

<p>\begin{equation}
Q_A = 2p^4 Q_A^2 - p^6 Q_A^4 + 2p^3(1-p)Q_A^2 \implies   \boxed{Q_A(-p^6 Q_A^3 + 2p^3Q_A - 1) = 0} 
\end{equation}</p>

<p>Now if we want to find the values of \(p\) for which there is a non-negative value for \(Q_A\) (the probability of Aaron winning the game from the first move), then we need to find the smallest value of \(p\) for which</p>

<p>\begin{equation}p^6 Q_A^3 - 2p^3Q_A + 1 = 0 \label{eq:QA_zero}\end{equation}</p>

<p>has a positive solution when we solve for \(Q_A\).</p>

<p>Note that (\ref{eq:QA_zero}) is a <em>cubic equation</em> in \(Q_A\) and thus will always have a real root. But, we need \(Q_A\) to be in the range \([0,1]\). The values of \(Q_A\) satisfying the above (\ref{eq:QA_zero}) for a fixed value of \(p\) are:</p>

<p><small>
\(\begin{align}
r_1 &amp; = \frac{4 \sqrt[3]{3} p^9+\sqrt[3]{2} \left(\sqrt{81 p^{24}-96 p^{27}}-9 p^{12}\right)^{2/3}}{6^{2/3} p^6 \sqrt[3]{\sqrt{81 p^{24}-96 p^{27}}-9 p^{12}}}\\
r_2 &amp; = -\frac{4 \sqrt[3]{3} p^9+\sqrt[3]{2} \left(\sqrt{81 p^{24}-96 p^{27}}-9 p^{12}\right)^{2/3}}{2\ 6^{2/3} p^6 \sqrt[3]{\sqrt{81 p^{24}-96 p^{27}}-9 p^{12}}} + i \left(\frac{ \left(3^{5/6} \left(2 \sqrt{81 p^{24}-96 p^{27}}-18 p^{12}\right)^{2/3}-12 \sqrt[3]{2} \sqrt[6]{3} p^9\right)}{12 p^6 \sqrt[3]{\sqrt{81 p^{24}-96 p^{27}}-9 p^{12}}}\right)\\
r_3 &amp; = \overline{r_2}
\end{align}\)
</small></p>

<p>The keen eye may notice that these are <em>gross</em> looking equations. As mentioned before, since our equation was cubic in \(Q_A\), one of these is guaranteed to be real. The other two are either both real or both complex. What do we see when we plot these out as a function of \(p\)?</p>

<h3><figure>
  <center>
  <img src="/assets/img/blog_images/JS_Aug_24/prob_plot.png" width="80%" style="display: block; margin: auto;" />
</center>
</figure></h3>

<p>We see that for \(p \leq\frac{3}{2^{5/3}} \approx  0.94\), there is only <em>one real root and it is negative</em>. However, for \(\boxed{p &gt; \frac{3}{2^{5/3}}}\), the <em>roots are all real with two positive and one negative</em>. This value of \(p\) comes from setting \(p\) to ensure that the term \(\sqrt{81 p^{24}-96 p^{27}}\) (which appears in each of the expressions for the roots), is real. Does this produce a valid probability value for \(Q_A\)?</p>

<p>For \(p\) just above this threshold value of \(\hat{p} = \frac{3}{2^{5/3}}\), we see \(Q_A\) has near repeated roots of around \(\approx 0.88\), validating our solution. Interestingly \(Q_A\) is <strong>zero</strong> until \(p &gt; \hat{p}\) at which it instantaneously jumps up to around \(Q_A \approx 0.88\), as seen in the plot above!</p>]]></content><author><name>Connor Colombe</name></author><category term="programming" /><summary type="html"><![CDATA[My solution to last month's puzzle]]></summary></entry><entry><title type="html">Jane Street March 2024 Puzzle Solution</title><link href="https://ccolombe12.github.io/blog/2024/JS_Hooks10/" rel="alternate" type="text/html" title="Jane Street March 2024 Puzzle Solution" /><published>2024-04-01T00:00:01+00:00</published><updated>2024-04-01T00:00:01+00:00</updated><id>https://ccolombe12.github.io/blog/2024/JS_Hooks10</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2024/JS_Hooks10/"><![CDATA[<style type="text/css">
    ol { list-style-type: lower-alpha; }
</style>

<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<h2 id="jane-street-hooks-10">Jane Street: Hooks 10</h2>

<p>My solution to the March 2024 month <a href="https://www.janestreet.com/puzzles/hooks-10-index/">Jane Street Puzzle: Hooks 10</a>.</p>

<p>The problem boils down to finding a feasible arrangement of hooks and cells for the given constraints. Luckily for me and my operations research background, this can essentially be represented as a large integer program (IP)! I saw this was the 10’th iteration of the Hooks puzzles and found (<a href="https://github.com/gowen100/Jane-Street-Solutions">Gowen100’s</a>) IP approach to the previous Hooks puzzle. This was a great opportunity to learn a new tool: The <a href="https://www.microsoft.com/en-us/research/project/z3-3/">Z3 theorem prover </a> from Microsoft research. I was able to use what I learned to create the necessary augmentations to solve the newest iteration of the the hooks puzzle! Looking forward to solving the future puzzles with this new tool!</p>

<iframe src="/assets/Jane_Street_Mar_2024.html" width="125%" height="900"></iframe>]]></content><author><name>Connor Colombe</name></author><category term="math" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">A Generalization of The Classic Bugs on A Square Problem.</title><link href="https://ccolombe12.github.io/blog/2023/Bugs_on_square/" rel="alternate" type="text/html" title="A Generalization of The Classic Bugs on A Square Problem." /><published>2023-12-16T00:00:01+00:00</published><updated>2023-12-16T00:00:01+00:00</updated><id>https://ccolombe12.github.io/blog/2023/Bugs_on_square</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2023/Bugs_on_square/"><![CDATA[<style type="text/css">
    ol { list-style-type: lower-alpha; }
</style>

<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<h2 id="problem-statement">Problem Statement</h2>
<p>In the classic bugs on a square problem, 4 bugs start out on the vertices of a square with side length 1. At \(t = 0\) the bugs all begin moving with speed \(v\) towards their counter-clockwise neighbor. The question is to determine how long the bugs take to reach the center of the square and how many rotations around the center will each bug make in doing so?</p>
<h3><figure><center>
  <img src="/assets/img/blog_images/Bugs_On_A_Square/square.png" />
 
</center></figure></h3>

<h2 id="solution">Solution</h2>

<p>Let’s first solve the square case and see if we can then generalize the argument. We will use polar coordinates and focus on the upper right bug. We can represent its position as a function of time as \((r(t), \phi(t))\), with initial conditions $r(0) = \sqrt{2}/2$ and $\phi(0) = \pi /4$.</p>

<p>The key here is to use symmetry to reason that at every moment in time, the bugs maintain their relative positions as the vertices of square. In otherwords, at each moment in time, the bugs remain in a square formation.</p>

<p>With this in mind, we can consider the bug’s position after a small change in time $\Delta t$.</p>
<h3><figure>
  <center>
  <img src="/assets/img/blog_images/Bugs_On_A_Square/square_dt.jpeg" style="width: 40vw; min-width: 330px;" zoomable="true" />
  <figcaption> Figure 2. A bug's relative position after a small moment in time $\Delta t$.
</figcaption> 
</center>
</figure></h3>
<p>The bug moves a distance $v \Delta t$ towards the it’s adjacent bug. We can then do some geometery to and use a small angle approximation to find the change in $r$ and $\phi$. Noting the right trangle we can form with hypotenuse $v \cdot \Delta t$, we have</p>

<p>\(\begin{align}
  r(t + \Delta t) - r(t) &amp; = - v \cdot  \Delta t \cos \theta\\ 
  r(t + \Delta t) \cdot \Delta \phi &amp; = v \Delta t \sin \theta
\end{align}\)
Rearranging these and taking the limit as $\Delta t \to 0$, we obtain</p>

\[\boxed{
\begin{align}
  r'(t)&amp; = - v \cos \theta\\ 
  \phi'(t) &amp; = \frac{v \sin \theta}{r(t)}.
\end{align}}\]

<p>We can solve (3) for \(r(t)\) using our initial condiditon  $\theta = \pi /4 $ and \(r(0) = 1/\sqrt{2}\) to get</p>

<p>\(\begin{equation}
  r(t) = - \frac{v}{\sqrt{2}}  t + \frac{1}{\sqrt{2}}.
\end{equation}\) 
It then follows that the time it takes to reach the center $T$ is \(T = \frac{1}{v}.\) Now that we have an equation for \(r(t)\) we can plug it into (4) and solve for $\phi(t)$ to get</p>

<p>\(\begin{equation}
\boxed{\phi(t) = \pi/4 - \log\left( 1 - v t\right)}.
\end{equation}\)
As \(t \to T\), we have \(\phi \to \infty\), implying that the bug makes an infinite number of rotations around the center of the circle as the approach the center!</p>

<p>This analysis was for the square but every step we used is actually applicable to the general case of a regular $n$-gon. In the general case \(\theta = 2 \pi / n\) and we can use the law-of-cosines and then a double angle formula for cosine to determine that \(r(0) = \frac{1}{\sqrt{2 \left(1 - \cos \left(\frac{2 \pi}{n} \right)\right)}} = \frac{1}{2 \sin \frac{\pi}{n}}\). Consider one of the \(n\) wedges from a regular $n$-gon shown below. Here the angle \(\alpha = \frac{\pi - 2\pi/n}{2} = \frac{\pi}{2} - \frac{\pi}{n}\).</p>

<h3><figure>



  <center>
  <img src="/assets/img/blog_images/Bugs_On_A_Square/n_gon.jpeg" style="width: 50vw; min-width: 330px;" zoomable="true" />
  <figcaption> Figure 2. A bug's relative position after a small moment in time $\Delta t$.
</figcaption> 
</center>
</figure></h3>

<p>Using our same steps as before, we find the differential equations</p>

\[\begin{align}
   r'(t)&amp; = - v \cos \alpha = - v \sin \frac{\pi}{n}\\ 
  \phi'(t) &amp; = \frac{v \sin \alpha}{r(t)} = \frac{v \cos \frac{\pi}{n}}{r(t)}.
\end{align}\]

<p>We can solve these once again with our initial conditions to get</p>

<p>\(\begin{equation}
  \boxed{r(t) = \frac{1}{2 \sin \left(\frac{\pi}{n}\right) }- v \sin \left(\frac{\pi}{n}\right)\;  t}.
\end{equation}\)
Which implies the time to reach the center for a bug on a regular $n$-gon is \(\boxed{T = \frac{1}{2 v \sin^2\left(\frac{\pi}{n}\right)}}\). Lastly we solve for \(\phi(t)\) to get 
\(\begin{equation}
  \boxed{\phi(t) =  \frac{\pi}{n} - \cot\left(\frac{\pi}{n}\right) \log \left(1 - 2 v \sin^2 \left(\frac{\pi}{n}\right) t\right)}.
\end{equation}\)
note again we recover that \(\phi(t) \to \infty\) as \(t \to T\) meaning the bug will always rotate around the center of the $n$-gon an infinite number of times as it approaches the center.</p>

<p>Can we say anything about these results for large $n$? We can make a rough approximation for large $n$ using the small-angle approximation for sine. For large enough \(n\), \(\begin{equation}T = \frac{1}{2 v \sin^2\left(\frac{\pi}{n}\right)} \approx \frac{1}{2 v \left(\frac{\pi}{n}\right)^2} = \frac{n^2}{2 \pi^2 v}
\end{equation}\) which grows unboundely as $n$ increases.</p>

<h3><figure>
  <center>
  <img src="/assets/img/blog_images/Bugs_On_A_Square/big_n_t.png" style="width: 50vw; min-width: 330px;" zoomable="true" />
  </center>
  <figcaption> Figure 3. The time it takes for a bug on an $n$-gon to reach the center for $v = 1$. The large $n$ approximation is shown in blue. We can see they agree rather quickly.
</figcaption> 

</figure></h3>

<p>Lastly, it is fun to look at the actual path of the bug as a function of time for different $n$.Here are the paths to the center of the first bug for \(n = 4\) and \(n=20\).</p>

<h3><figure>
  <center>
  <img src="/assets/img/blog_images/Bugs_On_A_Square/my_gif2.gif" style="width: 35vw; min-width: 330px;" />
  <figcaption> Figure 4. Path a bug take to the center on the unit square.
</figcaption> 
</center>
</figure></h3>

<h3><figure>
  <center>
  <img src="/assets/img/blog_images/Bugs_On_A_Square/my_gif.gif" style="width: 35vw; min-width: 330px;" />
  <figcaption> Figure 5. Path a bug take to the center on the unit 20-gon. </figcaption> 
</center>
</figure></h3>]]></content><author><name>Connor Colombe</name></author><category term="math" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Alice and Bob Play a Guessing Game</title><link href="https://ccolombe12.github.io/blog/2023/Alice_and_Bob_Guessing_game/" rel="alternate" type="text/html" title="Alice and Bob Play a Guessing Game" /><published>2023-10-16T00:00:01+00:00</published><updated>2023-10-16T00:00:01+00:00</updated><id>https://ccolombe12.github.io/blog/2023/Alice_and_Bob_Guessing_game</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2023/Alice_and_Bob_Guessing_game/"><![CDATA[<style type="text/css">
    ol { list-style-type: lower-alpha; }
</style>

<p>Here is another cool problem I stumbled upon the other day.</p>
<h2 id="problem-statement">Problem Statement</h2>
<p>Bob chooses a integer uniformly at random between 1 and 1000. Alice has to guess the chosen number as quickly as possible. Bob will let Alice know whether her guess is smaller than, larger than, or equal to his number. If Alice’s guess is smaller than Bob’s number, Bob replaces the number with another integer chosen uniformly at random from $[1,1000]$. Prove that there exists a strategy that Alice can use to finish the game in such a way that the expected number of steps is smaller than 45.</p>
<hr />

<h2 id="solution">Solution</h2>

<p>Let’s generalize and suppose Bob picks integers uniformly from the set \([N] = \{1,2,3,\ldots, N \}\). I initially set out to try to determine the <em>optimal</em> strategy using dynamic programming. Let \(E_k\) be the expected number of turns to finish the game given that we know that Bob’s current number is at most \(k\).</p>

<p>We can set up the recurrence</p>

\[\begin{equation}
E_k = 1 + \min_{j \in [k]}\left(\underbrace{\frac{k-j}{k}E_N}_{\text{guess too low}} + \underbrace{\frac{1}{k} \cdot 0}_{\text{guess correct}} + \underbrace{\frac{j-1}{k}E_j}_{\text{guess too high}}\right) \quad \forall k \in [N].
\end{equation}\]

<p>But since every \(k\) relies on \(E_n\), the quantity we are trying to solve for, this ends up to not be as straightforwards to evaluate as we might hope.</p>

<p>What else can we try? Well this problem is sort of similar to the <a href="https://brilliant.org/wiki/egg-dropping/#n-eggs-k-floors">egg drop problem</a> with one egg and each time it breaks we start with a new building with a randomly chosen number of floors. In the egg drop problem with two eggs, if the first egg breaks on the first floor tested, \(x\) then the next drops must necessarily be \(x-1, x-2, \ldots, 1\) until the least-breaking floor is found. Let’s try to build a heuristic strategy off this intuition.</p>

<p>We can pick some threshold \(\ell\) and use the strategy:</p>
<ul>
  <li>Guess \(\ell\) repeatedly until either we guess correct or Bob rolls a number less than \(\ell\).</li>
  <li>Guess down from \(\ell, \ell - 1, \ldots, 1\) until we hit the target</li>
</ul>

<p>The number of turns until the first step succeeds is a geometric random variable with parameter \(\ell/N\) and thus the expected number of turns until we succeed is \(N / \ell\). Now, given that the target number is at most \(\ell\), it has a uniform distribution over \(1,\ldots,\ell\) and thus the expected number of guesses needed to reach it is:
\(\begin{align*}
  \mathbb{E}[\text{# steps needed given step 1 succeeds}]&amp; = \underbrace{\frac{1}{\ell}\cdot 0}_{x = \ell} + \underbrace{\frac{\ell-1}{\ell}\left(\frac{1}{\ell - 1}\sum_{k=1}^{\ell-1} k\right)}_{x &lt; \ell}\\ 
  &amp; = \frac{\ell-1}{2}.
\end{align*}\)</p>

<p>Putting it together, let \(f(\ell)\) be the expected number of turns to guess Bob’s number under our strategy with threshold number \(\ell\). This is given by</p>

\[\begin{equation}
f(\ell) = \frac{N}{\ell} + \frac{\ell-1}{2}. \label{eq: f}
\end{equation}\]

<p>We would like to minimize this function. Taking the derivative, we find a single critical point at \(\boxed{\ell^* = \sqrt{2 N}}\), and the second derivative is positive for all $\ell &gt; 0$ which implies we have found a global minimum for our problem. Plugging this value into (\ref{eq: f}), we have that</p>

<p>\(\begin{equation}
  \boxed{f(\ell^*) = \sqrt{2 N} - \frac{1}{2}}
\end{equation}\)
which for \(N = 1000\) gives us an expected number of moves of \(\approx\) 44.2214 which is less than 45, as desired. This result is quite interesting! For large $N$, on average will will only need to guess \(\mathcal{O}\left(\frac{1}{\sqrt{N}}\right)\) fraction of the numbers.</p>]]></content><author><name>Connor Colombe</name></author><category term="math" /><summary type="html"><![CDATA[Here is another cool problem I stumbled upon the other day. Problem Statement Bob chooses a integer uniformly at random between 1 and 1000. Alice has to guess the chosen number as quickly as possible. Bob will let Alice know whether her guess is smaller than, larger than, or equal to his number. If Alice’s guess is smaller than Bob’s number, Bob replaces the number with another integer chosen uniformly at random from $[1,1000]$. Prove that there exists a strategy that Alice can use to finish the game in such a way that the expected number of steps is smaller than 45.]]></summary></entry><entry><title type="html">A Dice Game</title><link href="https://ccolombe12.github.io/blog/2023/Dice_game/" rel="alternate" type="text/html" title="A Dice Game" /><published>2023-10-14T00:00:00+00:00</published><updated>2023-10-14T00:00:00+00:00</updated><id>https://ccolombe12.github.io/blog/2023/Dice_game</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2023/Dice_game/"><![CDATA[<style type="text/css">
    ol { list-style-type: lower-alpha; }
</style>

<p>It’s no secret that I really enjoy solving interview brainteaser problems. I recently stumbled across a problem from a Jane Street Interview that I thought was interesting.</p>
<h2 id="problem-statement">Problem Statement</h2>
<p>The original problem is as follows: You are playing a game with a fair \(n\) sided dice, with faces 1 through \(n\) and \(T\) turns. The die starts with side 1 facing up. On each turn, you may either</p>

<ol>
  <li>Receive a payment equal to the value of the current face up side of the dice</li>
  <li>Re-roll the dice.</li>
</ol>

<p>The question is: What is the optimal strategy, and what is the most you would be willing to pay to play this game?</p>

<p>In this blog post we will consider a continuous version of the game and discuss how our insights would then carry over to the discrete case.</p>

<p>In our continuous case, instead of a discrete dice, we will play with a “dice” that acts as a uniform random number generator from \([0,1]\). We will also assume that we begin with a face up value of zero.</p>
<hr />

<h2 id="solution">Solution</h2>

<p>Before diving into calculations, we can think a about what form the optimal strategy may take. Our first insight is that on any given turn, if the current “face-up” side of the dice is very close to 1, we should probably choose to receive payment. Furthermore, if we are on our last turn, it doesn’t matter what side of the dice is up, it is optimal to choose to receive the payment. We can begin to reason that for \(k\) turns left, the optimal strategy might have some threshold function \(v_k\) where if on the \(k\)-th to last turn the face up value is \(x\) then it is optimal to receive payment only if \(x \geq v_k\) and it is optimal to re-roll otherwise.</p>

<p>First let’s try to show at there exists this threshold function. Let \(w(v,k)\) be the expected value of the game, under optimal play, starting with value \(v\) face up and having \(k\) turns left.</p>

<p>We have that \(w(v,0)= 0\) and a recurrence relation</p>

\[\begin{equation}
w(v,k)= \max\left\{\underbrace{v + w(v, k - 1)}_{\text{receive payout}}, \; \underbrace{\int_0^1 w(x, k - 1) \; dx}_{\text{re-roll}}\right\}.\label{eq: cont rec.}
\end{equation}\]

<p>We claim that \(w(v,k)\) is a continuous function in \(v\). This can be proven by induction on \(k\) and noting that taking the max of continuous functions preserves continuity.</p>

<p>Now, we claim that \(w(v,k)\) is a non-decreasing function in \(v\). This can again be proven by induction on \(k\) using (\ref{eq: cont rec.}). With these, If we consider the cases where \(v = 0\) and \(v = 1\), we see that</p>

<p>\(w(0,k-1) \leq \int_0^1 w(x, k - 1) \; dx\) and \(1 +w(1,k-1) &gt; \int_0^1 w(x, k - 1)\). It then follows by the fact that \(w(v,k)\) is continuous and non-decreasing and the intermediate value theorem that for each \(k\) there is some smallest value of \(v \in [0,1]\) such that receiving payout is optimal if the face up side is at least this value. It remains to find the for each \(k\) what this threshold \(v_k\) is.</p>

<p>We can reason that \(v_k\) ought to be an increasing in \(k\). That is, if you are willing to receive a payout of \(x\) with \(k\) turns remaining, then you would also be willing to accept it with at most \(k-1\) turns remaining. With this in mind, we can begin to derive a recurrence relation for \(v_k\).</p>

<p>Equation (\ref{eq: cont rec.}) and the existence of \(v_k\) imply that we have the equality \(\begin{equation}
v_k + w(v_k, k-1) = \int_0^1 w(x, k - 1) \;  \label{eq:v_k equal}.
\end{equation}\)</p>

<p>However, since \(v_k\) is an non-decreasing function, we have that \(v_k + w(v_k, k-1) =  k v_k\) (meaning that if we we take payout, we will keep taking that payout every turn until the game ends). If we denote \(I_k := \int_0^1 w(x, k)\), this give us the relation</p>

\[\begin{equation}
\boxed{k v_k = I_{k-1}} \label{eq:I_k def}
\end{equation}\]

<p>We can then expand the RHS of (\ref{eq:v_k equal}) as</p>

\[\begin{align*}
\int_0^1 w(x, k - 1) \; dx &amp; = \int_0^{v_{k-1} }w(x, k - 1)\; dx + \int_{v_{k-1} }^1 w(x, k - 1)\; dx\\ 
                    &amp; = \int_0^{v_{k-1} }\left(I_{k-2}\right)\; dx+ \int_{v_{k-1} }^1 (k-1) x \; dx\\ 
                    &amp; = v_{k-1} I_{k-2} + \frac{k-1}{2}\left(1 - v_{k-1} ^2\right)\\ 
                    &amp; = (k-1)v_{k-1}^2 + \frac{k-1}{2}\left(1 - v_{k-1} ^2\right)\\ 
                    &amp; = \frac{k-1}{2}\left(1 + v_{k-1}^2\right).
\end{align*}\]

<p>If we then combine this with (\ref{eq:v_k equal}) and (\ref{eq:I_k def}), we have a recurrence relation for \(v_k\)</p>

\[\begin{equation}
\boxed{v_k = \frac{k-1}{2k}\left(1 + v_{k-1}^2\right), \quad v_1 = 0} \label{eq:v_k req rel}.
\end{equation}\]

<p>Unfortunately, we cannot solve for a closed form solution to (\ref{eq:v_k req rel}). But we can solve for the numerical value of our game for a given number of turns. Starting with a current value of zero and \(T\) turns, the value of the game is given by \(w(0,T)\). Since $v_k &gt; 0$ for all \(k &gt; 1\), the optimal first move is to re-roll and which give us a value of 
\(\begin{equation}
  w(0,T) = \int_0^1 w(x, T-1) = I_{T-1} = T v_T
\end{equation}\)</p>

<p>Which means that the value of our game with \(T\) turns is \(\boxed{w(0,T)= Tv_T}\).</p>

<p>We can say a few more things about the continuous case before concluding with a few remarks on what the optimal strategy would be in the discrete case. Recall that \(v_k\) is increasing in \(k\). It is also bound above by 1. Therefore the monotone convergence theorem implies that \(v_k\) converges. In the limit we find that \(v_k\to 1\) which matches our intuition that with many turns remaining, we are willing to wait for a value very close to 1. Below are plots of \(v_k\) for \(k\leq 50\) and the value of the game for \(T \leq 50\)</p>

<h3><figure><center>
  <img width="300" src="/assets/img/blog_images/Dice_game/test.svg" class="img-fluid rounded z-depth-1" zoomable="true" />
</center></figure></h3>
<div class="caption">
    Fig 1: Plotting $v_k$ for for all $k \leq 50$.
</div>

<h3><figure><center>
  <img width="300" src="/assets/img/blog_images/Dice_game/game_vals.svg" class="img-fluid rounded z-depth-1" zoomable="true" />
</center></figure></h3>
<div class="caption">
    Fig 2: Plotting $w(0,T)$ for for all $T \leq 50$.
</div>

<p>To conclude, how might we use what we have found to tackle the discrete case? The analysis is exactly the same but now the cutoff thresholds will be discrete. The recurrence relation in (\ref{eq: cont rec.}) will now be</p>

<p>\(\begin{equation}
w(v,k)= \max\left\{\underbrace{v + w(v, k - 1)}_{\text{receive payout}}, \; \underbrace{\frac{1}{n} \sum_{u=1}^n w(u, k - 1)}_{\text{re-roll}}\right\}.\label{eq: disc rec.}
\end{equation}\)
Otherwise, the insights from the continuous case still hold!</p>]]></content><author><name>Connor Colombe</name></author><category term="math" /><summary type="html"><![CDATA[It’s no secret that I really enjoy solving interview brainteaser problems. I recently stumbled across a problem from a Jane Street Interview that I thought was interesting. Problem Statement The original problem is as follows: You are playing a game with a fair \(n\) sided dice, with faces 1 through \(n\) and \(T\) turns. The die starts with side 1 facing up. On each turn, you may either]]></summary></entry><entry><title type="html">Generalizing the “Drunk Pasenger” Problem</title><link href="https://ccolombe12.github.io/blog/2023/Drunk_passenger/" rel="alternate" type="text/html" title="Generalizing the “Drunk Pasenger” Problem" /><published>2023-08-16T00:00:01+00:00</published><updated>2023-08-16T00:00:01+00:00</updated><id>https://ccolombe12.github.io/blog/2023/Drunk_passenger</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2023/Drunk_passenger/"><![CDATA[<style type="text/css">
    ol { list-style-type: lower-alpha; }
</style>

<p>I recently stumbled across a problem that asked for a generalization of the “Drunk Passenger” problem. The classic problem is as follows:</p>
<h2 id="problem-statement">Problem Statement</h2>
<p>There are \(n\) seats on an airplane and \(n\) passengers. The passengers are in a line to board the plane and the \(i\)-th passenger in line is assigned to seat number \(i\) on the plane. However, the first passenger in line is drunk and takes a seat on the plane uniformly at random. The rest of the passengers take a on the plane seat one by one. Passenger \(i \geq 2\) will sit in their assigned seat if it is available, otherwise they will sit in an open seat uniformly at random. What is the probability the \(n\)-th passenger in line sits in their assigned seat?</p>

<p>The version of the problem we will solve is: find the probability that the \(k\)-th passenger in line sits in their assigned seat for \(k = 1,\ldots,n\).</p>
<hr />

<h2 id="solution">Solution</h2>

<p>Let \(P(n, k)\) be the probability that the \(k\)-th passenger sits in their assigned seat. Let’s do a little exploration. We can immediately reason that because the first passenger (\(k=1\)) always picks their seat uniformly at random, we have that \(P(n,1) = 1/n\) for all \(n\). But what about for \(k=2\) ? The second passenger will sit in their assigned seat only if the first passenger does not steal their seat. This implies \(P(n,2) = \frac{n-1}{n}\). For \(k \geq 3\), we rely on an important observation:</p>

<blockquote>
  <p>If the first passenger sits in seat \(i\) such that \(3 \leq  i \leq n\), then the passengers \(2,\ldots, i - 1\) will all sit in their assigned seats.</p>
</blockquote>

<p>We can now find \(P(n,k)\) by conditioning on three events:</p>

<ol>
  <li>The first passenger sits in seat \(1\).</li>
  <li>The first passenger sits in seat \(i\) where \(i &gt; k\).</li>
  <li>The first passenger sits in seat \(i\) where \(2 \leq i \leq k -1\).</li>
</ol>

<p>In events a) and c) passenger \(k\) sits in their assigned seat with probability 1. Event b) requires some more careful analysis.</p>

<p>Say passenger \(1\) sits in seat \(i\) such that \(2 \leq i \leq k -1\). In this case, passengers \(2,\ldots,i-1\) all get their assigned seats. Passenger \(i\), now without their assigned seat, will sit uniformly at random in one of the seats numbered \(1, i+1, i+2, \ldots, n\). But this is the same problem as before with passenger \(i\) as the new “drunk passenger” whose assigned seat is \(1\). In this smaller problem, there are \(n-i+1\) passengers and passenger \(k\) in the larger problem is now passenger \(k - i + 1\) in the smaller problem. Therefore in the event that passenger \(1\) sits in seat \(i\), the probability that passenger \(k &gt; i\) sits in their assigned seat is \(P(n+1 - i, k + 1 - i)\).</p>

<p>To put this all into a recurrence relation, we have</p>

\[\begin{equation}
\begin{split}
P(n,k) &amp; = \Pr\left[\text{$k$ sits in seat $k$}|\text{1 sits in seat 1} \right]\cdot \Pr[\text{1 sits in seat 1} ]\\ 
&amp;  + \Pr\left[\text{$k$ sits in seat $k$}|\text{1 sits in seat $i &gt; k$} \right]\cdot \Pr[\text{1 sits in seat $i &gt; k$} ]\\ 
&amp; + \sum_{i=1}^{k-1} \Pr\left[\text{$k$ sits in seat $k$}|\text{1 sits in seat $i$} \right]\cdot \Pr[\text{1 sits in seat $i$} ]\\ 
&amp; = 1 \cdot \frac{1}{n} + 1 \cdot \frac{n-k}{n} + \sum_{i=2}^{k-1}P(n+1 - i, k + 1 - i)\cdot \frac{1}{n}\\ 
&amp; = \frac{n+1 -k}{n} + \frac{1}{n} \sum_{i=2}^{k-1}P(n+1 - i, k + 1 - i)\\ 
&amp; = \frac{n+1 -k}{n} + \frac{1}{n} \sum_{i=1}^{k-2}P(n - i, k - i)\\
\end{split}\label{eq:recurrence}
\end{equation}\]

<p>with base cases \(P(n,1) = \frac{1}{n}\) and \(P(n,2) = \frac{n-1}{n}\) for all \(n\). But how might we go about evaluating (\ref{eq:recurrence})?</p>

<p>Well, by solving for a few small values of \(k\) by hand, we find that \(P(n,3) = \frac{n-2}{n-1}\) and \(P(n,4) = \frac{n-3}{n-2}\). This leads us to the following proposition which we will then prove by induction on \(k\).</p>

<div class="proposition">
For \(n \in \mathbb{Z}_+ \) and integer \(k \leq n\) the probability that passenger \(k\) sits in their assigned seat in the drunk passenger problem is 
\begin{equation}
    \boxed{P(n,k) = \begin{cases}
      \frac{n + 1 - k}{n + 2 - k} &amp; k\geq 2\\ 
      \frac{1}{n} &amp; k = 1.
      \end{cases}}
  \end{equation}
</div>

<p><em>Proof.</em></p>

<p>We will prove this by induction on \(k\). First note the base cases for \(P(n,1)\) holds. Then using (\ref{eq:recurrence}) we have \(P(n,2) = \frac{n-1}{n}\) which agrees with our previous results. These two base cases hold for all \(n \geq 2\). We will now proceed with the inductive hypothesis and assume the result holds for all \(k' &lt; k\). It now suffices to show \(P(n,k) = \frac{n + 1 - k}{n + 2 - k}\).</p>

<p>From (\ref{eq:recurrence}) we have 
\(\begin{equation}  
\begin{split}
P(n,k) &amp; = \frac{n + 1 - k}{n} + \frac{1}{n} \sum_{i=1}^{k-2}P(n - i, k - i)\\ 
       &amp; = \frac{n + 1 - k}{n} + \frac{1}{n} \sum_{i=1}^{k-2}\frac{(n-i) + 1 - (k-i)}{(n-i) + 2 - (k-i)}\\ 
       &amp; = \frac{n + 1 - k}{n} + \frac{1}{n} \sum_{i=1}^{k-2}\frac{n + 1 - k}{n + 2 - k}\\ 
       &amp; = \frac{n + 1 - k}{n} + \frac{k-2}{n}\cdot\frac{n + 1 - k}{n + 2 - k}\\
       &amp; = \frac{n + 1 - k}{n}\left(1  + \frac{k-2}{n + 2 - k}\right)\\
       &amp;  = \frac{n + 1 - k}{n}\left(\frac{n}{n + 2 - k}\right)\\
       &amp; = \frac{n + 1 - k}{n + 2 - k}
\end{split}
\end{equation}\)
as desired.
\(\begin{align*} &amp; \tag*{\(\blacksquare\)} \end{align*}\)</p>

<p>Based on this we do recover the classic result that \(P(n,n) = 1/2\). Taking the derivative of \(P(n,k)\) with respect to \(k\) we can see that it is a decreasing function in \(k\) and that the later in the line you are, the less likely it is you will sit in your assigned seat with a worst case probability of \(1/2\).</p>]]></content><author><name>Connor Colombe</name></author><category term="math" /><summary type="html"><![CDATA[I recently stumbled across a problem that asked for a generalization of the “Drunk Passenger” problem. The classic problem is as follows: Problem Statement There are \(n\) seats on an airplane and \(n\) passengers. The passengers are in a line to board the plane and the \(i\)-th passenger in line is assigned to seat number \(i\) on the plane. However, the first passenger in line is drunk and takes a seat on the plane uniformly at random. The rest of the passengers take a on the plane seat one by one. Passenger \(i \geq 2\) will sit in their assigned seat if it is available, otherwise they will sit in an open seat uniformly at random. What is the probability the \(n\)-th passenger in line sits in their assigned seat?]]></summary></entry><entry><title type="html">Throwing Darts</title><link href="https://ccolombe12.github.io/blog/2023/Throwing_Darts/" rel="alternate" type="text/html" title="Throwing Darts" /><published>2023-04-14T00:00:01+00:00</published><updated>2023-04-14T00:00:01+00:00</updated><id>https://ccolombe12.github.io/blog/2023/Throwing_Darts</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2023/Throwing_Darts/"><![CDATA[<h2 id="problem-statement">Problem Statement</h2>

<p>Jason throws two darts at a dartboard, aiming for the center. The second dart lands farther from the center than the first. If Jason throws a third dart aiming for the center, what is the probability that the third throw is farther from the center than the first? Assume Jason’s skillfulness is constant.</p>

<p><em>Challenge: What if, after the first, his
next \(n − 2\) throws are further from the center than the first? What is the probability that
the \(n\)-th throw is farther from the center than the first?</em></p>
<hr />

<h2 id="solution">Solution</h2>

<p>At first glance, it may seem that the information about the second throw is irrelevant. However, we shall see that that is not the case. We will present two solutions to this problem, both interesting in their own right. The first is perhaps a more traditional computational approach to the problem, and the second uses a cheeky symmetry argument.</p>
<hr />

<h1 id="solution-1">Solution 1</h1>
<p>We will solve the general problem and apply it to the \(n = 3\) case. Let \(R_1,R_2,\ldots, R_n \in [0,1]\) be i.i.d. random variables denoting the radii at which each of the consecutive dart throws land. We would like to evaluate
\(\begin{equation}
  \mathbb{P}\left[R_n &gt; R_1 | R_2 &gt; R_1 \cap \cdots \cap R_{n-1} &gt; R_1\right]
\end{equation}\)</p>

<p>Using Bayes Theorem, we can write this as 
\(\begin{equation}
  \mathbb{P}\left[R_n &gt; R_1 | R_2 &gt; R_1 \cap \cdots \cap R_{n-1} &gt; R_1\right] = \frac{\mathbb{P}\left[R_2 &gt; R_1 \cap \cdots \cap R_{n-1} &gt; R_1\ \cap \left(R_{n} &gt; R_1\right)\right]}{\mathbb{P}\left[R_2 &gt; R_1 \cap \cdots \cap R_{n-1} &gt; R_1\right]} \label{eq:solu}.
\end{equation}\)</p>

<p>Now it suffices to evaluate \(\begin{equation}  
\mathbb{P}\left[ \cap_{i = 2}^n R_{i} &gt; R_1\right] \label{eq:key}.
\end{equation}\)
In order to do this, we will need to know the probability distribution function for \(R\), denoted \(f(r)\). We can deduce this by considering the unit circle (dartboard) and imagine a thin concentric ring at radius \(r\) of width \(dr\). The area of this ring is \(2 \pi r \; dr\), the area of the circle is \(\pi\) and thus the probability of Jason throwing a dart and it landing at radius \(r\) is \(f(r) = 2 r \; dr\) (see Figure 1).</p>

<h3><figure><center>
  <img height="50" src="/assets/img/blog_images/2023-04-14-Throwing_Darts/fig_dart_prob.png" class="img-fluid rounded z-depth-1" zoomable="true" />
</center></figure></h3>
<div class="caption">
    Figure 1. Depicting the small area on a unit dartboard where a dart can land at a radius in $[r,r + dr]$.
</div>
<p>This then implies,</p>

\[\begin{equation}
  \mathbb{P}\left[R &gt; r\right] = \mathbb{P}\left[R \geq r\right] = 1 - r^2.
\end{equation}\]

<p>We can then evaluate (\ref{eq:key}) by conditioning on the value of \(R_1\).</p>

\[\begin{align*}
  \mathbb{P}\left[ \cap_{i = 2}^n R_{i} &gt; R_1\right] &amp; = \int_0^1 (1-r^2)^{n-1} 2 r \; dr \\ 
  &amp; = 2 \int_0^1 (1-r^2)^{n-1} r \; dr  \\
  &amp; = 1/ n.
\end{align*}\]

<p>Based on this, we can write (\ref{eq:solu}) as</p>

\[\begin{align*}
 \mathbb{P}\left[R_n &gt; R_1 | R_2 &gt; R_1 \cap \cdots \cap R_{n-1} &gt; R_1\right] &amp; = \frac{\mathbb{P}\left[R_2 &gt; R_1 \cap \cdots \cap R_{n-1} &gt; R_1\ \cap \left(R_{n} &gt; R_1\right)\right]}{\mathbb{P}\left[R_2 &gt; R_1 \cap \cdots \cap R_{n-1} &gt; R_1\right]}  \\ 
 &amp; = \frac{1/n}{1/(n-1)}\\ 
 &amp; = \frac{n-1}{n}\\ 
 &amp; = \boxed{1 - \frac{1}{n}}.
\end{align*}\]

<p>Plugging in \(n = 3\) yields the solution to our original problem \(\boxed{2/3}\).</p>
<hr />

<h1 id="solution-2">Solution 2</h1>

<p>Imagine that all of the throws have already occurred and we are revealing them one at a time. Up until the final throw, the first throw is the closest to the center of the dartboard. We are asked to find, given this knowledge, what is the probability that the first throw is the closest of all of the throws. At this point, the only way this could <em>not</em> be the case if is the last throw is the closest to the center of the \(n\) throws. Since his skill is constant, the probability that his last throw is the closest to the center is the same as for any other throw, \(1/n\). Therefore, the probability that the first throw was the closest of the \(n\) throws given it was closer than the next \(n-2\) throws is \(\boxed{1 - \frac{1}{n}}\).</p>]]></content><author><name>Connor Colombe</name></author><category term="math" /><summary type="html"><![CDATA[Problem Statement]]></summary></entry></feed>