<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://ccolombe12.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ccolombe12.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2025-08-29T21:57:44+00:00</updated><id>https://ccolombe12.github.io/feed.xml</id><title type="html">blank</title><subtitle>The academic webpage of Connor Colombe
</subtitle><entry><title type="html">Jane Street Puzzle: Robot Road Trip</title><link href="https://ccolombe12.github.io/blog/2025/robot-road-trip/" rel="alternate" type="text/html" title="Jane Street Puzzle: Robot Road Trip" /><published>2025-08-01T00:00:01+00:00</published><updated>2025-08-01T00:00:01+00:00</updated><id>https://ccolombe12.github.io/blog/2025/robot-road-trip</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2025/robot-road-trip/"><![CDATA[<h2 id="problem-statement">Problem Statement</h2>
<blockquote>
  <p>Robot cars have a top speed (which they prefer to maintain at all times while driving) that’s a real number randomly drawn uniformly between $1$ and \(2\) miles per minute. A two-lane highway for robot cars has a fast-lane (with minimum speed \(a\)) and a slow-lane (with maximum speed \(a\)). When a faster car overtakes a slower car in the same lane, the slower car is required to decelerate to either change lanes (if both cars start in the fast-lane) or stop on the shoulder (if both cars start in the slow-lane). Robot cars decelerate and accelerate at a constant rate of $1$ mile per minute per minute, timed so the faster, overtaking car doesn’t have to change speed at all, and passing happens instantaneously.</p>
</blockquote>

<blockquote>
  <p><strong>If cars rarely meet (so you never have to consider a car meeting more than one other car on its trip, see Mathematical clarification below), and you want to minimize the miles not driven due to passing, what should \(a\) be set to, in miles per minute? Give your answer to 10 decimal places.</strong></p>
</blockquote>

<blockquote>
  <p><em>Mathematical clarification:</em>  Say car trips arrive at a rate of $z &gt; 0$ car trip beginnings per mile per minute, uniformly across the infinite highway (cars enter and exit their trips at their preferred speed due to on/off ramps), and car trips have a constant length of \(N\) miles. Define \(f(z,N)\) to be the value of $a$ that minimizes the expected lost distance per car trip due to passing. Find:</p>
</blockquote>

\[a^* = \lim_{N \to \infty} \lim_{z \to 0^+} f(z,N)\]

<hr />
<h2 id="solution">Solution</h2>

<p>At a high-level, our solution will do the following:</p>

<ul>
  <li>For car $C$ entering the roadway at a given location, time, and speed, determine the necessary conditions for another car to overtake $C$ during $C$’s journey.</li>
  <li>Determine, for each overtake, the total miles not driven due to passing</li>
  <li>Combine these two to determine the expected miles not driven due to passing for a car traveling at speed $v$.</li>
  <li>Average over all $v$ and determine the optimal speed threshold $f(z, N)$ for the highway.</li>
  <li>Determine $a^* = \lim_{N \to \infty} \lim_{z \to 0^+} f(z,N)$</li>
</ul>

<p>Before diving into the analysis, we will point out an observation from the mathematical clarification. Suppose we have an infinitely long highway at which cars enter at rate $z$ starts/mile/minute. Based on this description, we can say that the number of cars that enter the highway on a strip of length $\Delta x$ during a duration of time $\Delta t$ is a <a href="https://en.wikipedia.org/wiki/Poisson_distribution">Poisson random variable</a> with mean/rate $\lambda = z \Delta x \Delta t$. An important property of Poisson random variables is that their sum is also a Poisson random variable in which their rates have been added. With this in mind, we begin our analysis.</p>

<p>Let us consider a car $C$ that enters the highway (WLOG) at $x = 0$ and $t = 0$ with speed $v \in [1, 2]$. This car will travel for $N / v$ minutes and exit the highway at its destination $x = N$. We would like to determine the distribution for the number of cars will catch up to and pass $C$. First some observations. For a car $C’$ to pass car $C$, it must meeting the following conditions:</p>

<ul>
  <li>Have speed $u &gt; v$ (It is moving faster than $C$).</li>
  <li>If it starts its trip at time $t = t_s$, $C’$ must be behind where $C$ is at $t = t_s$ (It must start behind $C$ to overtake it).</li>
  <li>Share the same position as $C$ at some time $t$ during the time interval at which both cars are driving.</li>
</ul>

<p>Using these, we would like to get a distribution for the number of cars that will pass $C$.
Let us start by fixing the speed of car $C’$, to be some $u$ such that $u &gt; v$. What are the conditions on the starting time and position of $C’$ that will allow it to pass $C$? Suppose $C’$ starts at position $x_s$ at time $t_s$ and the two cars intersect at time $t$. Based the previous conditions, we get the following inequalities:</p>

\[\begin{align}
&amp; t_s \leq t \leq t_s + N/u &amp;&amp; (\text{intersect while $C'$ exists})  \\
&amp; 0 \leq t \leq N/v &amp;&amp; (\text{intersect while $C$ exists}) \\
&amp; x_s + u(t - t_s) = v t &amp;&amp; (\text{Both at same location at time $t$}) \label{eq:same_x}.
\end{align}\]

<p>Using (\ref{eq:same_x}), we can solve for $t$ as $t = \frac{u t_s - x_s}{u - v}$ and plug this into the other inequalities to get a set of four inequalities in the $(x_s, t_s)$-space.</p>

\[\begin{align}
&amp; t_s \leq \frac{u t_s - x_s}{u - v} \leq t_s + N/u  \\
&amp; 0 \leq \frac{u t_s - x_s}{u - v} \leq N/v \\
\end{align}\]

<p>Which when plotted in the $(x_s, t_s)$-space, these inequalities define a region $R$ which is a convex quadrilateral. This region is the set of all pairs of $(x_s, t_s)$ that would allow $C’$, traveling at speed $u$ to intersect $C$. See an example below.</p>

<figure>
    <img src="/assets/img/blog_images/2025_08_01-robot-roadtrip/fig1.png" width="70%" style="display: block; margin: auto;" />
     <figcaption style="text-align: center;">Figure 1: Example of the region in $(x_s, t_s)$-space, $R$, in which cars of speed $u$ will overtake $C$.</figcaption>
</figure>

<p>The vertices of $R$ are given by</p>

\[\begin{align*}
P_1 &amp; = (0, 0)\\
P_2 &amp; = (0, \frac{N(u - v)}{uv})\\
P_3 &amp; = (N, N/v) \\
P_4 &amp; = (-N, -N/u),
\end{align*}\]

<p>which imply that the area of our quadrilateral is \(\boxed{ Area(R) = \frac{N^2 (u - v)}{uv}}\).</p>

<p>Using our earlier observation about the number of cars for a given region of time and space being a Poisson random variable with parameter proportional to the area of that region, we deduce that the distribution for the number of  which cars of speed $u$ that arrive in the time-space region $R$ is a Poisson random variable with rate parameter $\lambda(u)$ given by</p>

\[\lambda(u) = z dF(u) \frac{N^2 (u - v)}{uv}  = z \frac{N^2 (u - v)}{uv} du.\]

<p>Where $z dF(u)$ is the rate at which car of speed $u$ arrive per mile per minute. Since the speed of cars is distributed $U(1, 2)$, we have $dF(u) = du / 1$.</p>

<p>We now have enough to compute the rate of overtakes for $C$ when it is in the slow-lane $\Lambda_S$ and when it is in the fast-lane, $\Lambda_F$.</p>

<p>For the slow-lane, we have</p>

\[\begin{align*}
\Lambda_S  &amp; = \int_v^a z \frac{N^2 (u - v)}{uv} du \\ 
&amp; = \frac{N^2 z \left(a  - v \log \left(\frac{a e}{v}\right)\right)}{v}.
\end{align*}\]

<p>And for the fast-lane</p>

\[\begin{align*}
\Lambda_F  &amp; = \int_v^2 \frac{N^2 (u - v)}{uv} du \\ 
&amp; = \frac{N^2 z \left(2  -v \log \left(\frac{2e}{v}\right)\right)}{v}.
\end{align*}\]

<p>These are the expected number of intersections per trip for a car of speed $v$, depending on whether the car is in the slow-lane or the fast-lane (since they are Poisson random variables). Now, we need to determine the “loss of distance traveled” for each overtake in either scenario.</p>

<p>Suppose we are in the slow-lane. Whenever we are passed, we must fully stop and then speed up to speed $v$ again. Since the acceleration is fixed to be $1$, the time it take to stop and speed up are the same and is $\delta t = v$ minutes. The total distance that would be traveled during this time without intersection is</p>

\[d_0 = v(\delta t + \delta t) = 2 v^2.\]

<p>On the other hand, when we have to stop, the distance traveled during the deceleration is</p>

\[d_1 = v \delta t - \frac{1}{2}(\delta t)^2 = v^2 / 2,\]

<p>and acceleration</p>

\[d_2 =\frac{1}{2}(\delta t)^2 = v^2 / 2.\]

<p>Thus the “loss of distance” for each passing in the slow-lane is:</p>

<p>\(\boxed{d_0 - d_1 - d_2 = v^2}\).</p>

<p>By similar calculations, we find the “loss of distance” per passing in the fast-lane is:</p>

\[\boxed{(v - a)^2}.\]

<p>Putting these together, for a car of speed $v$ the expected lost distance due to passing, $\ell(v)$, is given by:</p>

\[\begin{align*}
\boxed{
\ell(v) = \begin{cases} v^2 \cdot \frac{N^2 z \left(a  - v \log \left(\frac{a e}{v}\right)\right)}{v} &amp; v \leq a \\
(v - a)^2  \cdot \frac{N^2 z \left(2  -v \log \left(\frac{2e}{v}\right)\right)}{v} &amp; v &gt; a
\end{cases}}
\end{align*}\]

<p>Since the speed of cars is distributed $U(1, 2)$, we need to compute the expected total lost distance for a car entering the highway with speed threshold $a$, denoted $L(a)$. We find</p>

\[\begin{align*}
L(a) &amp; = \int_{1}^2 \ell(v)\;  d v \\ 
     &amp; =\frac{1}{18} N^2 z \bigg(a^3 (18+\log (64))+18 a^2 (\log (4)-1)-6 \left(a^3+6 a^2-1\right) \log (a)-45 a+16\bigg).
\end{align*}\]

<p>Now, for fixed $z$ and $N$, we would like to find the value of $a$ that minimizes the above expression. However, note that $N$ and $z$ simply contribute a positive scaling factor and do not affect minimizing the overall expression. Therefore, it suffices to remove the constant factors and instead minimize the function</p>

\[g(a) := a^3 (18+\log (64))+18 a^2 (\log (4)-1)-6 \left(a^3+6 a^2-1\right) \log (a)-45 a+16.\]

<p>If we plot $g(a)$ over the interval $a \in [1,2]$, (see Figure 2) it appears that the function should have a unique minimizer over the desired interval.</p>

<figure>
    <img src="/assets/img/blog_images/2025_08_01-robot-roadtrip/fig2.pdf" width="70%" style="display: block; margin: auto;" />
    <figcaption style="text-align: center;">Figure 2: Plot of the loss function $g(a)$ over [1,2]</figcaption>
</figure>

<p>Unfortunately, there is not a nice closed form solution for the minimizer, so we will have to solve for it numerically. Doing so yields for fixed $N$ and $z$,</p>

\[\begin{equation*}
\boxed{f(z, N) = 1.177141417}
\end{equation*}\]

<p>taking the limit of which for $N$ and $z$ has no effect, and thus we have found the value of $a^*$ that minimizes the expected lost distance due to passing.</p>

<p>This value is pretty close to the minimum end of possible speeds on the highway! Around $82\%$ of the cars, on the highway are in the fast-lane. Why might that be? Well we can note that it is pretty expensive for a car in the slow-lane to be passed. Since $v \geq 1$ the loss of distance for every car in the slow-lane is at least $1$ whereas the maximum penalty for a passing in the fast-lane <em>is at most</em> 1. We see that passings in the slow-lane are much more expensive and thus we would need to have fewer of them than in the fast-lane in an optimal solution.</p>

<p>This was a fun problem that had me brushing up on my Poisson processes. I even found several problems in the Poisson Process section of <a href="https://www.amazon.com/Stochastic-Processes-Sheldon-M-Ross/dp/0471120626">Sheldon Ross’s Stochastic Processes textbook</a> that were about cars entering a highway according to a similar rule which served as a great warm-up to tackling this problem!</p>]]></content><author><name></name></author><category term="programming," /><category term="math" /><summary type="html"><![CDATA[My solution to the 2025 July Puzzle]]></summary></entry><entry><title type="html">Can You Throw the Hammer?</title><link href="https://ccolombe12.github.io/blog/2025/hammer_toss/" rel="alternate" type="text/html" title="Can You Throw the Hammer?" /><published>2025-04-21T00:00:00+00:00</published><updated>2025-04-21T00:00:00+00:00</updated><id>https://ccolombe12.github.io/blog/2025/hammer_toss</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2025/hammer_toss/"><![CDATA[<p>This week’s <a href="https://thefiddler.substack.com">The Fiddler on the Proof</a> puzzle is paraphrased as follows:</p>

<blockquote>
  <p>You (Player 1) and your opponent (Player 2) are competing in a <a href="https://tglgolf.com">TGL golf match</a>. On any given hole you play, each of you has a 50-percent chance of winning the hole (and a zero percent chance of tying). That said, scorekeeping in this match is a little different from the norm.</p>
</blockquote>

<blockquote>
  <p>Each hole is worth 1 point. Before starting each hole, either you or your opponent can “throw the hammer.” When the hammer has been thrown, whoever did not throw the hammer must either accept the hammer or reject it. If they accept the hammer, the hole is worth 2 points. If they reject the hammer, they concede the hole and its 1 point to their opponent. Both players can throw the hammer on as many holes as they wish. (Should both players decide to throw the hammer at the exact same time—something that can’t be planned in advance—the hole is worth 2 points.)</p>
</blockquote>

<blockquote>
  <p>The first player to reach \(n\) points wins the match. Suppose all players always make rational decisions to maximize their own chances of winning. <strong>If the first player wins the first hole and the score is \((1 - 0)\) what is the probability that they win the match?</strong></p>
</blockquote>

<p><br /><br /></p>

<h2 id="solution"><strong>Solution</strong></h2>

<p>This is a quick one this week! For each round, the players are playing in a <a href="https://en.wikipedia.org/wiki/Zero-sum_game">zero-sum game</a>.We can view them as competing for the “resource” that is the probability that they win the overall game given the current round. To solve for the probability that Player 1 wins from the score-state \((1,0)\), which we denote as \(V(1, 0)\), we need to develop a recursive relationship for \(V(i, j)\), the probability that the first player wins from state \((i, j)\) (Player 1 has \(i\) points and Player 2 has \(j\) points).</p>

<p>We observe that, at the start of each turn each player has two actions to start the turn: throw the hammer or do not throw the hammer. In the case that they do not throw the hammer, then they may have to then make the secondary choice of “accept” or “reject” if the other player chooses to throw their hammer. We adopt the convention that Player 1 chooses their actions based on the objective of <em>maximizing</em> the probability that they win the overall game at state \((i, j)\), \(V(i, j)\). Conversely, Player 2 chooses actions with the objective of <em>minimizing</em> this \(V(i, j)\). This leads us to the recurrence relation:</p>

\[\begin{equation}
\begin{aligned}
V(i,j) = &amp;  \max\Bigl\{\,%
\underbrace{\min\bigl\{\tfrac12\,V(i+2,j) + \tfrac12\,V(i,j+2),\;V(i+1,j)\bigr\}}_{\text{Player 1 Tosses Hammer}},\\
&amp;\quad \underbrace{\min\Bigl\{\,
   \tfrac12\, V(i+1,j) + \tfrac12\,V(i,j+1),\;
   \max\bigl\{\tfrac12\,V(i+2,j) + \tfrac12\,V(i,j+2),\;V(i,j+1)\bigr\}
\Bigr\}}_{\text{Player 1 does not toss Hammer}} \Bigr\}. 
\end{aligned}\label{eq:rec}
\end{equation}\]

<p>With the base case(s) of</p>

\[\begin{align}
V(n, j)  = 1 &amp; \quad \forall \; j \in [n - 1] &amp;&amp; \text{(Player 1 has won)}\\
V(i, n)  = 0 &amp; \quad \forall \; i \in [n - 1] &amp;&amp; \text{(Player 1 has lost)}
\end{align}\]

<p>Here we can see Player 1 is taking the action that maximizes their probability of winning the game given that, if they took a particular action, Player 2 would choose the action to minimize Player 1’s probability of winning under that action. We see in (\ref{eq:rec}) that in the case Player 1 chooses not to hammer, they may then face a secondary decision to accept or reject a Player 2 hammer toss, in which they would again choose the probability-maximizing action.</p>

<p>We can code this recurrence up in python using <a href="https://www.geeksforgeeks.org/dynamic-programming/">Dynamic Programming</a> and visualize the probability of Player 1 winning at any given state. Here we have actually taken the liberty of slightly generalizing the problem. We are assuming that the Player 1’s probability of winning on round \(i + j\) (the current round, zero indexed) is known and is given by a list <code class="language-plaintext highlighter-rouge">hole_probs</code>. In the context of our original problem, every entry of <code class="language-plaintext highlighter-rouge">hole_probs</code> would be \(1/2\)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">functools</span> <span class="kn">import</span> <span class="n">cache</span>

<span class="nd">@cache</span>
<span class="k">def</span> <span class="nf">V</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s"> Probability Player 1 wins the game given we are at state (i, j) and they
    are playing to score n. We assume there is some list of probabilities 
    hole_probs such that hole_probs[i + j] is the probability that Player 1
    wins the current hole.  </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="c1"># the prob Player 1 wins current hole   
</span>    <span class="n">p</span> <span class="o">=</span> <span class="n">hole_probs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> 

    <span class="c1"># Player 1 hammers
</span>    <span class="n">prob_toss_win</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span>
        <span class="n">p</span> <span class="o">*</span> <span class="nc">V</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="nc">V</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span> 
        <span class="nc">V</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Player 1 does not hammer
</span>    <span class="n">prob_pass_win</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span>
        <span class="n">p</span> <span class="o">*</span> <span class="nc">V</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="nc">V</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
        <span class="nf">max</span><span class="p">(</span>
            <span class="n">p</span> <span class="o">*</span> <span class="nc">V</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="nc">V</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">),</span>
            <span class="nc">V</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
     <span class="p">)</span>

    <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">prob_toss_win</span><span class="p">,</span> <span class="n">prob_pass_win</span><span class="p">)</span>  

<span class="c1"># now input problem specific parameters and solve 
</span><span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">hole_probs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)]</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s"> The probability of Player 1 winning is </span><span class="si">{</span><span class="nc">V</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div>
<p>With this, we can get visualize the probability of Player 1 winning from any state. Here are two examples of the original problem (each player is equally skilled) for small and large \(n\).</p>
<figure style="max-width: 100%;">
  <div style="display: flex; justify-content: space-between; align-items: flex-start;">
    <div style="width: 48%;">
      <img src="/assets/img/blog_images/2025-04-18-hammer/winning_heatmap.png" style="width: 100%; display: block;" alt="Heatmap small" />
    </div>
    <div style="width: 48%;">
      <img src="/assets/img/blog_images/2025-04-18-hammer/heatmap_2_5050.png" style="width: 100%; display: block;" alt="Heatmap large" />
    </div>
  </div>
  <figcaption style="text-align: center; margin-top: 0.5em;">
    Comparison of win‑probability heatmaps (Player 1 perspective) for equally skilled opponents: \(n = 5\) on the left and \(n = 50\) on the right.
  </figcaption>
</figure>

<p>It’s worth noting that <strong>the “no hammer” option is never used by either player in this setting</strong>. For any \(n\) we can compute the value of \(V(1,0)\) in \(\mathcal{O}(n^2)\) time using our dynamic programming approach. For small \(n\), Player 1 has a significant advantage (for example \(n =3\) has \(V(1, 0) = 3/4\)) but as \(n\) increases, the value of \(V(1, 0)\) approaches \(1/2\) as we might expect.</p>

<p>Just for fun, we can also test out a different <code class="language-plaintext highlighter-rouge">hole_probs</code> distribution and see how this changes things. One interesting scenario is when Player 1 gradually improves over time. Specifically, at state \((i, j)\) the probability that they win the round is given by</p>

\[p_{ij} = \frac{i + j}{2n - 2}\]

<p>(as the round number increases Player 1 gets linearly better). Initially Player 1 would be very bad and unlikely to win, but in the higher rounds they would be increasingly more clutch over Player 2.</p>

<p>The win‑probability heatmaps now look like the figures below, revealing three asymmetric regions of the state space (one favoring each player and one where they are neutral). In this case, we see the “no hammer” option become used more widely.</p>
<figure style="max-width: 100%;">
  <div style="display: flex; justify-content: space-between; align-items: flex-start;">
    <div style="width: 48%;">
      <img src="/assets/img/blog_images/2025-04-18-hammer/heatmap_3_clutch.png" style="width: 100%; display: block;" alt="Heatmap small" />
    </div>
    <div style="width: 48%;">
      <img src="/assets/img/blog_images/2025-04-18-hammer/heatmap_clutch_larger.png" style="width: 100%; display: block;" alt="Heatmap large" />
    </div>
  </div>
  <figcaption style="text-align: center; margin-top: 0.5em;">
    Comparison of win‑probability heatmaps (Player 1 perspective) when Player 1 gets increasingly better (linearly): \(n = 50\) on the left and \(n = 300\) on the right.
  </figcaption>
</figure>

<p>Lastly, here is one more scenario where</p>

\[p_{ij} = \left(\frac{i + j}{2n - 2}\right)^2\]

<p>Here Player 1 still improves over the rounds but their skill grows quadratically. See if you can come up with your own funky distribution and see what the heatmap looks like using the code above and below!</p>

<figure style="max-width: 100%;">
  <div style="display: flex; justify-content: space-between; align-items: flex-start;">
    <div style="width: 48%;">
      <img src="/assets/img/blog_images/2025-04-18-hammer/heatmap_quad50.png" style="width: 100%; display: block;" alt="Heatmap small" />
    </div>
    <div style="width: 48%;">
      <img src="/assets/img/blog_images/2025-04-18-hammer/heatmap_quad_300.png" style="width: 100%; display: block;" alt="Heatmap large" />
    </div>
  </div>
  <figcaption style="text-align: center; margin-top: 0.5em;">
    Comparison of win‑probability heatmaps (Player 1 perspective) when Player 1 gets increasingly better (quadratic): \(n = 50\) on the left and \(n = 300\) on the right.
  </figcaption>
</figure>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">hole_probs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
<span class="c1">#hole_probs = [i / (2 * n  - 2) for i in range(2 * n - 1)]
#hole_probs = [np.sqrt(i / (2 * n  - 2)) for i in range(2 * n - 1)]
#hole_probs = [(i / (2 * n  - 2)) ** 2 for i in range(2 * n - 1)]
</span><span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">for n = </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s">, the probability of Player 1 winning from the start is </span><span class="si">{</span><span class="nc">V</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s"> and with a 1 point lead is </span><span class="si">{</span><span class="nc">V</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">plot_prob_win_heatmap</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s"> heatmap of win probabilities V(i, j) for 0 &lt;= i, j &lt; n.</span><span class="sh">"""</span>
    <span class="c1"># matrix of V(i, j) 
</span>    <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="nc">V</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
    
    <span class="c1"># plot the heatmap
</span>    <span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">imshow</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="sh">'</span><span class="s">lower</span><span class="sh">'</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="sh">'</span><span class="s">RdYlGn</span><span class="sh">'</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="sh">'</span><span class="s">nearest</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">colorbar</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="sh">'</span><span class="s">Probability of Win</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$i$, Player 1 score</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">$j$, Player 2 score</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sa">fr</span><span class="sh">'</span><span class="s">Player $1$ Win Probability Heatmap for $n = </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s">$</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>

<span class="c1"># try it out 
</span><span class="nf">plot_prob_win_heatmap</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[My solution to this week's Fiddler on the Proof Puzzle]]></summary></entry><entry><title type="html">Can You Solve a High Schooler’s Favorite Puzzle?</title><link href="https://ccolombe12.github.io/blog/2025/HS_fav_puzzle/" rel="alternate" type="text/html" title="Can You Solve a High Schooler’s Favorite Puzzle?" /><published>2025-04-08T00:00:00+00:00</published><updated>2025-04-08T00:00:00+00:00</updated><id>https://ccolombe12.github.io/blog/2025/HS_fav_puzzle</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2025/HS_fav_puzzle/"><![CDATA[<p>This week’s <a href="https://thefiddler.substack.com">The Fiddler on the Proof</a> puzzle is paraphrased as follows:</p>

<blockquote>
  <p>A teacher is handing out candy to his \(N\) students, of which \(N \geq 4\). He abides by the following rules:</p>
</blockquote>

<blockquote>
  <p>He hands out candy to groups of three students (i.e., “trios”) at a time. Each member of the trio gets one piece of candy. Each unique trio can ask for candy, but that same trio can’t come back for seconds. If students in the trio want more candy, they must return as part of a different trio.
When a trio gets candy, the next trio can’t contain any students from that previous trio.</p>
</blockquote>

<blockquote>
  <p>It turns out that <em>every</em> possible trio can get a helping of candy. <strong>What is the smallest class size \(N\) for which this is possible?</strong></p>
</blockquote>

<p><br /><br /></p>
<h2 id="solution">Solution</h2>

<p>Instead of focusing on the case of trios, we will generalize the problem and consider groups of \(k\) students. If there is some ordering of groups such that every group of \(k\) students can receive candy, what is the smallest such \(N\) for which this is possible? Denote this smallest \(N\) as \(N(k)\).</p>

<p>Now, what are some initial observations we can make about the problem? Well, first off, we can actually place the lower bound that \(N(k) \geq 2 k + 1\). This is because if there are any fewer students, then we cannot find a sequence of 3 initial \(k\)-groups. This was the only bound I could find in my initial exploration—the problem turned out to be much harder than I expected!</p>

<p>Perhaps changing our perspective can help us gain traction on the problem. What if we instead thought of the students as <strong>nodes</strong> in a graph and two nodes share an <strong>edge</strong> only if their representative groups are disjoint. Now, a <a href="https://en.wikipedia.org/wiki/Path_(graph_theory)">path</a> in this graph would then represent a sequence of groups that could get candy such that every group in the sequence is disjoint from the groups adjacent to it in the sequence. If we could find a path such that every node appeared in it exactly once, then we would have found a sequence of groups that allows every group to get candy! Such a path in a graph where every node is visited exactly once is called a <a href="https://en.wikipedia.org/wiki/Hamiltonian_path">Hamiltonian path</a>. Our problem has now become, for what \(N\) does a Hamiltonian path exist for a given \(k\)?</p>

<p>It turns out that determining whether a Hamiltonian path exists in a graph <em>is a <a href="https://en.wikipedia.org/wiki/NP-completeness">hard problem</a></em>. But perhaps there are some special properties our graph that make it a tractable endeavor without having to perform a brute-force search.</p>

<p>We need to first better describe our graph. Suppose for now, we fix some \(N \geq 2 k + 1\) and construct our graph as follows:
The set of nodes \(V\) is the set of subsets of size \(k\) from the group of \(N\) students. Nodes \(u, v \in V\) share an undirected edge if \(u \cap v = \emptyset\). This graph will have \(\binom{N}{k}\) nodes. For a given node \(u\), it will have \(\binom{N - k}{k}\) edges (one to each of the groups that it shares no members with) and thus by the handshake lemma, the graph has \(\frac{\binom{N}{k}\binom{N - k}{k}}{2}\) edges.</p>

<p>Now that we have a clearer picture of the graph, is there a particular aspect of it that allows us to determine if it has a Hamiltonian path? It turns out there is. One especially nice property of our graph is that it is <em>vertex transitive</em>. In simple terms, vertex transitive implies that from every node in the graph, the graph “looks the same” from the perspective of that node. It turns out that there is an open conjecture, the <a href="https://en.wikipedia.org/wiki/Lovász_conjecture">Lovász Conjecture</a> that states:</p>
<blockquote>
  <p><em>Lovász conjecture: Every finite, connected, vertex regular graph has a Hamiltonian cycle (and thus a Hamiltonian path).</em></p>
</blockquote>

<p>While this is an open conjecture, it implies that there is some evidence to suggest: as long as our choice of \(N\) allows our graph to be connected, since it is vertex transitive, it may indeed contain a Hamiltonian path. This leads us to the natural question, for what \(N\) is our graph connected?</p>

<p>It turns out that for \(N \geq 2k + 1\), our graph is connected! To see why, consider any two distinct nodes \(u, v \in V\). If \(u \cap v = \emptyset\), then they share an edge by definition. Otherwise, Suppose \(u\) represents the group of students \((A, S)\) and \(v\) represents the students \((B, S)\) where \(A \cap B = \emptyset\) and \(\|S\| = x\). Under this framing, we can show that that the set of students \(W\) that are not in  \(u \cup v\) has size \(x + 1\). We can now construct a path from \(u \to v\) using the following intuition.</p>

<p>We make a path that has the form</p>

\[(A, S) \to (B, W') \to (A, S') \to (B, W'') \to (A, S'')\to   \dots \to (B, S)\]

<p>where we use the extra student in \(W\) to iteratively swap in one more student of \(S\) into the group with \(B\) and vice versa until the subgroup paired with the \(B\) subgroup eventually becomes the desired \(S\) subgroup <sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>.</p>

<p>Now that we have argued that \(N=2k + 1\) is sufficient for our graph to be connected, and we have “evidence” now that suggests this should also be sufficient for there to exist a hamiltonian path, what else can we do except also conjecture that \(N(k) = 2k + 1\) and call it a day? Well it turns out that our graph with \(N = 2k + 1\) nodes is actually a special and well-studied graph. It turns out for \(N = 2 k + 1\), we have actually described the <em><a href="https://en.wikipedia.org/wiki/Odd_graph">Odd Graph</a></em>, \(O_{k + 1}\) which, for \(k \geq 3\),  <strong>is known to contain a Hamiltonian cycle (and thus a path)!</strong><sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>  Therefore, our choice of \(N = 2k + 1\) will ensure that every grouping of children can get candy and since this is the lower bound on possible values of \(N\), we indeed have that</p>

\[\boxed{N(k) = 2k + 1}.\]

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>To really see how this works, try to do this with the case of \(k= 3\) and \(N = 7\). <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>A bit anticlimactic that we’re able that we are able to simply point to the literature and call it a day but, but that’s research sometimes! This was a great problem to learn more graph theory! <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><summary type="html"><![CDATA[My solution to this week's Fiddler on the Proof Puzzle]]></summary></entry><entry><title type="html">Can You Grow a Hibiscus Hedge?</title><link href="https://ccolombe12.github.io/blog/2025/hibiscus-hedge/" rel="alternate" type="text/html" title="Can You Grow a Hibiscus Hedge?" /><published>2025-04-08T00:00:00+00:00</published><updated>2025-04-08T00:00:00+00:00</updated><id>https://ccolombe12.github.io/blog/2025/hibiscus-hedge</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2025/hibiscus-hedge/"><![CDATA[<p>This week’s <a href="https://thefiddler.substack.com">The Fiddler on the Proof</a> puzzle is paraphrased as follows:</p>

<blockquote>
  <p><strong>Part 1:</strong>  You have many flowers in three colors: red, orange, and yellow. You want to plant them in a straight row such that the order appears somewhat random, but not truly random. More specifically, you want the following to be true:</p>
  <ul>
    <li>No two adjacent flowers have the same color.</li>
    <li>No ordering of three consecutive flowers appears more than once in the row.</li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>What is the maximum number of flowers the row can contain?</strong></p>
</blockquote>

<blockquote>
  <p><strong>Part 2:</strong>  In addition to red, orange, and yellow flowers, you now have a fourth color: pink! Again, you want to plant a straight row of flowers that appears somewhat random. The new rules are:</p>
  <ul>
    <li>No two adjacent flowers have the same color.</li>
    <li>No ordering of four consecutive flowers appears more than once in the flower row.</li>
    <li>Among any group of four consecutive flowers, at least three distinct colors are represented.</li>
  </ul>
</blockquote>

<blockquote>
  <p><strong>What is the maximum number of flowers the row can contain now?</strong></p>
</blockquote>

<p><br /><br /></p>

<h2 id="solution"><strong>Solution</strong></h2>

<h3 id="part-1"><strong>Part 1:</strong></h3>

<p>Let’s first establish an upper bound on how long our row of flowers <em>could</em> be. Since each possible pattern of three flowers can appear only once, the longest imaginable row contains each pattern exactly once. The total number of patterns can be calculated:</p>
<ul>
  <li>\(3\) choices for the first color</li>
  <li>\(2\) for the second</li>
  <li>\(2\) for the final color</li>
</ul>

<p>Which gives the grand total of \(12\) total color patterns. As each pattern overlaps by two flowers, the longest possible row length is \(14\). But, can we achieve this maximum?</p>

<p>We verify using backtracking with Python</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Rectangle</span>
<span class="c1"># lets write a function that, given the current state, sees how many flowers we can place
</span><span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">r</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">o</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">y</span><span class="sh">'</span><span class="p">]</span>

<span class="c1"># we need to write some helpers that allow us to check if we can place a color 
# given the current sequence of colors so far 
</span>
<span class="c1"># check the triplet formed is not a repeat 
</span><span class="k">def</span> <span class="nf">no_triplet</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cur_triplet</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">+</span> <span class="n">color</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">cur_triplet</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>

<span class="c1"># check for adjacent color and not a new triplet 
</span><span class="k">def</span> <span class="nf">can_place</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">color</span> <span class="ow">and</span> <span class="nf">no_triplet</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>

<span class="c1"># returns the max len flower array given the current placement
</span><span class="k">def</span> <span class="nf">max_flower</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="n">best</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="n">best_flower</span> <span class="o">=</span> <span class="n">state</span>
    <span class="k">for</span> <span class="n">color</span> <span class="ow">in</span> <span class="n">colors</span><span class="p">:</span>
        <span class="k">if</span> <span class="nf">can_place</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
            <span class="n">cur_flower</span><span class="p">,</span> <span class="n">cur_size</span> <span class="o">=</span> <span class="nf">max_flower</span><span class="p">(</span><span class="n">state</span> <span class="o">+</span> <span class="n">color</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cur_size</span> <span class="o">&gt;</span> <span class="n">best</span><span class="p">:</span>
                <span class="n">best</span> <span class="o">=</span> <span class="n">cur_size</span>
                <span class="n">best_flower</span> <span class="o">=</span> <span class="n">cur_flower</span>
    
    <span class="k">return</span> <span class="n">best_flower</span><span class="p">,</span> <span class="n">best</span>

<span class="c1"># just assume the base flower is 'ro'
</span><span class="n">best_flower</span><span class="p">,</span> <span class="n">best_size</span> <span class="o">=</span> <span class="nf">max_flower</span><span class="p">(</span><span class="sh">'</span><span class="s">ro</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Best flower:</span><span class="sh">'</span><span class="p">,</span> <span class="n">best_flower</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">Best size:</span><span class="sh">'</span><span class="p">,</span> <span class="n">best_size</span><span class="p">)</span>


<span class="c1"># Now lets visualize the best flower as a sequence of rectangles 
</span><span class="kn">import</span> <span class="n">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="n">color_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">r</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">red</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">o</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">orange</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">y</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">yellow</span><span class="sh">'</span><span class="p">}</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="nf">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">best_flower</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">letter</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">best_flower</span><span class="p">):</span>
    <span class="n">rect</span> <span class="o">=</span> <span class="nc">Rectangle</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color_mapping</span><span class="p">[</span><span class="n">letter</span><span class="p">])</span>
    <span class="n">ax</span><span class="p">.</span><span class="nf">add_patch</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span>
    
<span class="n">ax</span><span class="p">.</span><span class="nf">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">best_flower</span><span class="p">))</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="nf">axis</span><span class="p">(</span><span class="sh">'</span><span class="s">off</span><span class="sh">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
            
</code></pre></div></div>
<p>Which gives us the output and visualized longest flower:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Best flower: roroyryoyoryro
Best size: 14
</code></pre></div></div>

<figure>
  <center>
  <img src="/assets/img/blog_images/2025-04-11-hibiscus/bush.png" width="80%" style="display: block; margin: auto;" />
  <figcaption> An example of an optimal flower row of length 14 
</figcaption> 
</center>
</figure>

<p>Confirming that we can indeed reach the longest possible flower length of \(\boxed{14}\) under the conditions!</p>

<h2 id="part-2"><strong>Part 2</strong></h2>

<p>For the extra credit, we can still use the backtracking approach but given the increased state space size, it might take a while. We can try another approach to handle the larger state space <em>integer programming</em> with the <a href="https://www.microsoft.com/en-us/research/project/z3-3/">z3 module</a>. With this approach, we will answer the <a href="https://en.wikipedia.org/wiki/Decision_problem">decision problem</a>:</p>

<blockquote>
  <p>for a given \(n\), does there exist a feasible flower row of length \(n\)?</p>
</blockquote>

<p>Using the answer to this decision problem, we can <em>binary search</em> over the space of the possible lengths to find the largest \(n\) such that there exists a feasible flower row.</p>

<p>Before we implement this, we need to again place an upper bound on the largest possible flower row so that we know the range of sizes we are to search over. Using a similar logic as in Part 1, along with the additional constraint that for any \(4\) adjacent flowers we need at least \(3\) distinct colors, we can show that there are \(96\) such possible color patterns. Therefore the largest possible flower row has size \(99\). Now it remains to model the decision procedure with the z3 module in python and then binary search over the space of possible lengths \([4, 96]\).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">z3</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="n">itertools</span> <span class="kn">import</span> <span class="n">combinations</span>

<span class="k">def</span> <span class="nf">flower_problem</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">The decision procedure: returns True if there exists a feasible flower row
    of size n with k colors. </span><span class="sh">"""</span>
    <span class="c1"># The n decision variables (color of each flower)
</span>    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="nc">Int</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">x_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    
    <span class="c1"># Constraints:
</span>    <span class="n">s</span> <span class="o">=</span> <span class="nc">Solver</span><span class="p">()</span>
    <span class="c1"># 1)  Each flower must have a color 
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nc">And</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    
    <span class="c1"># 2) No two adjacent colors match
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># 3) no repeated k-patterns 
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># Build the disjunction: at least one position l in {0,..., k-1} is different.
</span>            <span class="n">diff</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">l</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
            <span class="n">s</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nc">Or</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>
    
    <span class="c1"># 4) Each k-block must contain at least k-1 distinct colors.
</span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">block</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="p">]</span>
        <span class="c1"># we need to check all combinations of k - 1 colors in the block
</span>        <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nf">combinations</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">t</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nc">Distinct</span><span class="p">([</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]))</span>
        <span class="n">s</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nc">Or</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
    
    <span class="c1"># Try to solve 
</span>    <span class="k">if</span> <span class="n">s</span><span class="p">.</span><span class="nf">check</span><span class="p">()</span> <span class="o">==</span> <span class="n">sat</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="nf">model</span><span class="p">()</span>
        <span class="c1"># Return the solution as a list of integers.
</span>        <span class="k">return</span> <span class="p">[</span><span class="n">m</span><span class="p">.</span><span class="nf">evaluate</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]).</span><span class="nf">as_long</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>
</code></pre></div></div>

<p>Performing a binary search over the range of possible flower values with \(k = 4\), we find that \(\boxed{99}\) is the maximal achievable flower row length.</p>

<figure>
  <center>
  <img src="/assets/img/blog_images/2025-04-11-hibiscus/shrub2.png" width="100%" style="display: block; margin: auto;" />
  <figcaption> An example of an optimal flower row with 4 colors. It has length 99.
</figcaption> 
</center>
</figure>

<p>For our two cases (four if you include the trivial \(k = 1\) and \(k = 2\) cases), it seems that we can find a way to include <em>all</em> possible length \(k\) flower combinations without violating our constraints. This might lead us to suspect that, in general, it is possible to construct a flower row that includes all the possible valid <sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup> length \(k\) flower combinations. If this were true, what would the maximal length of a flower row consisting of \(k\) colors, \(M(k)\) be?</p>

<p>To calculate this, we need only consider how many possible valid length \(k\) flower combinations there are. We have two cases,</p>

<ul>
  <li><strong>Case 1:</strong> All the flowers are different: In this case there are exactly \(k!\) such valid combinations</li>
  <li><strong>Case 2:</strong> There is a repeat flower color:  In this case there is exactly one flower color excluded. There are \(k\) ways to choose the excluded color and then \(k - 1\) ways to choose the color to be repeated of the remaining colors. Now to order the flowers, we place the duplicate color first. There are \(\binom{k}{2} - (k - 1)\) ways to pick the spots they will be placed without them being adjacent and lastly there are \((k - 2)!\) ways to place the remaining flowers.</li>
</ul>

<p>Combining Cases 1 and 2, we find that the maximum flower length that satisfies our constraints on \(k\) flowers is:</p>

\[\begin{align*}
M(k) &amp; = k! + k(k-1) \left(\binom{k}{2} - (k - 1)\right) + k -1\\
&amp;   = \boxed{k!\left(2 +\binom{k}{2} - k \right) + k - 1}
\end{align*}\]

<p>So, is it possible to achieve this upper bound for all \(k\), as our few experiments suggest might be true? Well, it turns out that if we instead model our problem as a graph where the nodes are the valid length \(k\) flower orderings and two nodes \(u, v\) are connected via directed edge  \(u \to v\) if the last \(k-1\) colors of u are the first \(k-1\) colors of \(v\), then our problem is reduced to finding a hamiltonian path on the nodes! Fortunately, our <a href="https://ccolombe12.github.io/blog/2025/HS_fav_puzzle/">post last week</a> introduced the <a href="https://en.wikipedia.org/wiki/Lovász_conjecture">Lovász Conjecture</a> which again, suggests <sup id="fnref:2"><a href="#fn:2" class="footnote" rel="footnote" role="doc-noteref">2</a></sup> that this graph (finite, connected, and  vertex-transitive) will have admit a hamiltonian path! Therefore we have some reasonably strong evidence that our value of \(M(k)\), can be achieved!</p>

<p>We can use our z3 model to generate an example of a maximal flower row with \(k = 5\) colors (we have made the 5th color blue here)! As predicted it was length \(M(5) = 844\).</p>

<figure>
  <center>
  <img src="/assets/img/blog_images/2025-04-11-hibiscus/shrub3.png" width="100%" style="display: block; margin: auto;" />
  <figcaption> An example of an optimal flower row with 5 colors. It has length 844.
</figcaption> 
</center>
</figure>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>Meaning that they have no repeated adjacent colors and at least \(k - 1\) colors appear in them. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>This is still an open conjecture, so this is not a proof. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><summary type="html"><![CDATA[My solution to this week's Fiddler on the Proof Puzzle]]></summary></entry><entry><title type="html">Can You Root for the Underdog?</title><link href="https://ccolombe12.github.io/blog/2025/underdog/" rel="alternate" type="text/html" title="Can You Root for the Underdog?" /><published>2025-03-28T00:00:00+00:00</published><updated>2025-03-28T00:00:00+00:00</updated><id>https://ccolombe12.github.io/blog/2025/underdog</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2025/underdog/"><![CDATA[<p>This week’s <a href="https://thefiddler.substack.com">The Fiddler on the Proof</a> puzzle is paraphrased as follows:</p>

<blockquote>
  <p>There are \(2^n\) teams playing in a single-elimination seeded tournament. The teams play in a traditional seeded tournament format. That is, in the first round, the sum of teams playing each other is \(2^n + 1\) (for example seed \(1\) plays seed \(2^n\), \(2\) plays \(2^n - 1\), etc). If the stronger team always advances, then the sum of opponents’ seeds in the second round is \(2^{n - 1} + 1\), and so on.</p>
</blockquote>

<blockquote>
  <p>Each team possesses a “power index” equal to \(2^n + 1\) minus that team’s seed. For example, team \(1\) has power index \(2^n\). In any given matchup, the team with the <em>greater power index would emerge victorious</em>. However, March Madness fans love to root for the underdog. As a result, the team with the <em>lower</em> power index gets an effective “boost”  \(B\) applied to their power index, where \(B\) is some positive non-integer.</p>
</blockquote>

<blockquote>
  <p>As an illustration, consider the matchup between the \(2\) and \(3\)-seeds. The favored \(2\)-seed has a power index of \(3\), while the underdog \(3\)-seed has a power index of \(2+B\). When \(B\) is greater than \(1\), the \(3\)-seed will defeat the \(2\)-seed in an upset.</p>

  <p>Depending on the value of \(B\), different teams will win the tournament. <strong>Of the \(2^n\) teams, how many can never win, regardless of the value of \(B\)</strong>?</p>
</blockquote>

<p><br /><br /></p>
<h2 id="solution">Solution</h2>

<p>We can start out with some observations. First, for fixed \(B\), the winner of the tournament is deterministic. This suggests we should define a function \(W_n(B)\) that for a given \(n\) and \(B\) returns the winning seed in the tournament. To solve our problem, we could then determine which values that \(W_n(B)\) can and cannot take on. The next useful observation is that for \(B &gt; 2^n - 1\), the value of \(W_n(B)\) is a constant. Specifically, for \(B &gt; 2^n - 1\), the lowest seeded team will always win the tournament. Thus we need only consider the non-integral values of \(W_n(B)\) on the interval \(B \in [0, 2^n]\). The last observation we need to consider is that for any two teams playing, say with seeds \(a\) and \(b\) with \(a &lt; b\), the value of \(B\) for which the winner and loser of the game swap is \(b - a + \epsilon\) where \(\varepsilon &gt; 0\) is an arbitrarily small constant. Therefore, as we vary \(B\) from \(0 \to 2^n\), the only values of \(B\) where we may see the value of \(W_n(B)\) change are of the form \(k + \varepsilon\) where \(k\) is a non-negative integer.</p>

<p>With those observations, our strategy for solving the problem can be made clear. For \(B = k + \varepsilon\) for \(k \in [2^n - 1]\), determine the value of \(W_n(B)\) for the given value of \(B\) and keep track of the winners as we iterate over the values of \(B\).  Then simply report the values in \([2^n]\) that were not found to be winners.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">gen_bracket</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Recursively generate a seeded bracket for n players (n must be a power of 2).
    Returns a list where consecutive elements form a matchup.
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="nf">gen_bracket</span><span class="p">(</span><span class="n">n</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">mirror</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">seed</span> <span class="k">for</span> <span class="n">seed</span> <span class="ow">in</span> <span class="n">prev</span><span class="p">]</span>
        <span class="n">bracket</span> <span class="o">=</span> <span class="p">[</span><span class="n">seed</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">mirror</span><span class="p">)</span> <span class="k">for</span> <span class="n">seed</span> <span class="ow">in</span> <span class="n">pair</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">bracket</span>

<span class="k">def</span> <span class="nf">winner</span><span class="p">(</span><span class="n">seedA</span><span class="p">,</span> <span class="n">seedB</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Returns the winner of the matchup seedA vs seedB in an 
    N person tournament with boost B.
    </span><span class="sh">"""</span>
    <span class="c1"># make sure seedA is lower seed 
</span>    <span class="k">if</span> <span class="n">seedA</span> <span class="o">&gt;</span> <span class="n">seedB</span><span class="p">:</span>
        <span class="n">seedA</span><span class="p">,</span> <span class="n">seedB</span> <span class="o">=</span> <span class="n">seedB</span><span class="p">,</span> <span class="n">seedA</span>
    <span class="n">power_rankA</span> <span class="o">=</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">seedA</span>
    <span class="n">power_rankB</span> <span class="o">=</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">seedB</span> <span class="o">+</span> <span class="n">B</span>
    <span class="k">if</span> <span class="n">power_rankA</span> <span class="o">&gt;</span> <span class="n">power_rankB</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">seedA</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">seedB</span>
    

<span class="k">def</span> <span class="nf">W</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s"> 
    The winner of a 2^n person tournament with boost B. 
    </span><span class="sh">"""</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">n</span> 
    <span class="n">bracket</span> <span class="o">=</span> <span class="nf">generate_bracket</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c1"># keep simulating until one team left 
</span>        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">bracket</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bracket</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">winners</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">bracket</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">seedA</span> <span class="o">=</span> <span class="n">bracket</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">seedB</span> <span class="o">=</span> <span class="n">bracket</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">winners</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="nf">winner</span><span class="p">(</span><span class="n">seedA</span><span class="p">,</span> <span class="n">seedB</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span>
            <span class="n">bracket</span> <span class="o">=</span> <span class="n">winners</span>
</code></pre></div></div>

<p>Then to get the possible winners for a given tournament size of \(2^n\) and to compute 
the number of teams that cannot win, we can run the below code.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="mi">6</span> <span class="c1"># solve for 2^6 = 64 teams 
</span>    
<span class="n">can_win</span> <span class="o">=</span> <span class="nf">defaultdict</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
<span class="c1"># B-values where winner could swap values
</span><span class="n">B_space</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">eps</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> 
<span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">B_space</span><span class="p">:</span>
    <span class="n">champ</span> <span class="o">=</span> <span class="nf">tournament_winner</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">can_win</span><span class="p">[</span><span class="n">champ</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">winners</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">sorted</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">can_win</span><span class="p">.</span><span class="nf">keys</span><span class="p">())))</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">The teams that CAN win are </span><span class="si">{</span><span class="n">winners</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">There are </span><span class="si">{</span><span class="mi">2</span> <span class="o">**</span> <span class="n">n</span>  <span class="o">-</span> <span class="nf">len</span><span class="p">(</span><span class="n">winners</span><span class="p">)</span><span class="si">}</span><span class="s"> teams that cannot win</span><span class="sh">'</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">'</span><span class="s">The function that predicts this is </span><span class="si">{</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div>

<p>Since this code is for general \(n\), we can compute the number of teams that cannot 
win for several values of \(n\), see table 1.</p>

<figure>
    <center>
    <img src="/assets/img/blog_images/2025-03-28-Underdog/Teams_cant_win.png" alt="Table1" width="70%" style="display: block; margin: auto;" />
    <figcaption> Table 1: The number of teams that cannot win in a \(2^n\) team tournament regardless of \(B\).
    </figcaption>
    </center>
</figure>

<p>Some of you may notice a pattern in this sequence. If we let \(a_n\) be the number of teams that cannot win in a \(2^n\) team tournament, then we see the pattern emerge</p>

\[a_n = 2 a_{n - 1} + (n - 3), \; a_2 = 1\]

<p>for \(n \geq 2\). Which would suggest that</p>

\[\boxed{a_n = 2^{n - 1} - (n -  1)}.\]

<p>We won’t attempt prove this conjecture here, but the pattern holds for \(n \leq 20\).</p>

<p>Lastly, it would be interesting to see the plot of \(W_n(B)\) for various \(n\) so that we can get a sense of which teams are capable of winning. Below in Figure 1 is a gif that illustrates the function \(W_n(B)\) for various values of \(n\). We see that as \(n\) grows the shape of the function begins to approach some interesting limiting shape! 
<br /></p>

<figure>
  <center>
  <img src="/assets/img/blog_images/2025-03-28-Underdog/wnB_loop.gif" width="80%" style="display: block; margin: auto;" />
  <figcaption> Figure 1. Plots of the winning team function, \(W_n(B)\) for various \(n\).
</figcaption> 
</center>
</figure>

<p>Upon inspection it appears there is a recursive description of how these curves relate to one another. Here is a very rough description of how they appear related.  We see for a given \(n\), for \(B &gt; 2^{n - 1}\), the \(W_n(B)\) is non-decreasing in \(B\) and produces \(2^{n - 2} + 1\) unique winners in that range. The curve for \(W_{n + 1}(B)\) has the same values as \(W_n(B)\) for \(B &lt; 2^{n - 1}\). Then for \(B \in [2^{n - 1}, 2^n]\), the previously increasing portion of the curve is reflected downward about its start point, and then for \(B &gt; 2^n\), the curve has the same monotonic behavior but for \(2^{n -1} + 1\) values. Note that for all \(n \geq 2\), \(W_n(B)\) is a one-to-one function. That is,  no winner is ever repeated for different \(B\). If this behavior is indeed an accurate description of the curves (as it empirically appears to be), then this would prove our conjecture about \(a_n\) <sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>Can you show the equivalence? <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Connor Colombe</name></author><summary type="html"><![CDATA[My solution to this week's Fiddler on the Proof Puzzle]]></summary></entry><entry><title type="html">A Pi-Day Puzzle</title><link href="https://ccolombe12.github.io/blog/2025/Pi_day/" rel="alternate" type="text/html" title="A Pi-Day Puzzle" /><published>2025-03-14T00:00:00+00:00</published><updated>2025-03-14T00:00:00+00:00</updated><id>https://ccolombe12.github.io/blog/2025/Pi_day</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2025/Pi_day/"><![CDATA[<p>This week’s <a href="https://thefiddler.substack.com">The Fiddler on the Proof</a> puzzle is paraphrased as follows:</p>

<blockquote>
  <p>You are planning a picnic on the remote tropical island of \(\pi\)-land. The island’s shape is a perfect semi-disk with two beaches, as illustrated below. We have <strong>Semicircular Beach</strong> (along the northern semicircular edge of the disk) and <strong>Diametric Beach</strong> (along the southern diameter of the disk).</p>

  <p><strong>Part 1:</strong><br />
<em>If you pick a random spot on \(\pi\)-land for your picnic, what is the probability that it will be closer to Diametric Beach than to Semicircular Beach?</em></p>

  <p><strong>Part 2:</strong><br />
<em>Given the radius of \(\pi\)-land is 1, on average, what will be the expected shortest distance to shore?</em></p>
</blockquote>

<figure>
    <img src="/assets/img/blog_images/2025-03-14-Pi_day/Pi_island.png" alt="Illustration of the island" width="80%" style="display: block; margin: auto;" />
    <figcaption style="text-align: center;">Figure 1: The island.</figcaption>
</figure>

<hr />

<h2 id="solution">Solution</h2>

<h3 id="part-1">Part 1</h3>

<p>The immediate intuition is that the set of points closer to the Diametric Beach than the Semicircular Beach should form a well-defined geometric region. If we can determine that region, denoted \(D\), the desired probability is simply the area of that region divided by the area of the entire semicircle.</p>

<p>Let the island’s radius be 1, its center be at \((0, 0)\), and denote the points on the island by the region \(C\). Consider a point \((x, y)\) on the island, which beach is it closer to? The <strong>distance to Diametric Beach</strong> is just its \(y\)-coordinate. What about the <strong>distance to Semicircular Beach</strong>?</p>

<p>The shortest path from \((x, y)\) to Semicircular Beach is along the radial line through \((0,0)\) and \((x,y)\).<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup> This means the shortest distance to the Semicircular Beach is given by:</p>

\[1 - \sqrt{x^2 + y^2}\]

<p>Therefore, for a point to be <strong>closer to the Diametric Beach than the Semicircular Beach</strong>, the following inequality must hold:</p>

\[y \leq 1 - \sqrt{x^2 + y^2}\]

<p>Rearranging:</p>

\[y \leq \frac{1 - x^2}{2}\]

<p>Thus, the region \(D\) of points closer to the Diametric Beach than the Semicircular Beach is:</p>

\[D = \left\{ (x, y) \in C \mid y \leq \frac{1 - x^2}{2} \right\}.\]

<p>This region is depicted below:</p>

<figure>
    <img src="/assets/img/blog_images/2025-03-14-Pi_day/semicircle_plot.png" alt="Geometric region solution" width="80%" style="display: block; margin: auto;" />
    <figcaption style="text-align: center;">Figure 2: The region closer to the Diameter Beach than the Semicircular Beach (Blue).</figcaption>
</figure>

<p>Now, we compute the area of this region using integration:</p>

\[\text{Area}(D)  = \int_{-1}^1 \int_0^{\frac{1-x^2}{2}} dy \; dx = \frac{2}{3}.\]

<p>Since the total area of the semicircle is \(\frac{\pi}{2}\), the <strong>probability of being closer to the Diametric Beach is</strong>:</p>

\[\boxed{\frac{\text{Area}(D)}{\text{Area}(C)} = \frac{2/3}{\pi / 2} = \frac{4}{3\pi}}\]

<hr />

<h3 id="part-2">Part 2</h3>

<p>We’ve already done most of the heavy lifting in part 1)! Define \(L\) as the random variable representing the shortest distance to a beach. At a given point \((x, y) \in C\):</p>

<ul>
  <li>If \((x, y) \in D\), the shortest distance is \(y\).</li>
  <li>If \((x, y) \in D^c\), the shortest distance is \(1 - \sqrt{x^2 + y^2}\).</li>
</ul>

<p>Breaking up the expectation integral into two parts and solving yields:</p>

\[\begin{align*}
\mathbb{E}[L] &amp; = \frac{1}{\pi /2} \int_C \min\left(y, 1 - \sqrt{x^2 + y^2}\right) dy \; dx \\ 
&amp; = \frac{1}{\pi/2} \int_D y \; dy \; dx + \frac{1}{\pi/2} \int_{D^c} \left(1 - \sqrt{x^2 + y^2}\right) dy \; dx\\ 
&amp; = \frac{1}{\pi/2} \int_{-1}^1\int_0^{\frac{1-x^2}{2}} y \; dy \; dx + \frac{1}{\pi/2} \int_{-1}^1\int_{\frac{1-x^2}{2}}^{\sqrt{1 - x^2}}1 - \sqrt{x^2 + y^2}  \; dy \; dx\\
 &amp; = \boxed{\frac{1}{3} - \frac{4}{9 \pi}}
\end{align*}\]

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>Can you prove this? <em>Hint: Use the triangle inequality.</em> <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Connor Colombe</name></author><category term="math" /><summary type="html"><![CDATA[My solution to this week's Fiddler on the Proof Puzzle]]></summary></entry><entry><title type="html">How Many Rabbits Can You Pull out of a Hat?</title><link href="https://ccolombe12.github.io/blog/2025/fiddler/" rel="alternate" type="text/html" title="How Many Rabbits Can You Pull out of a Hat?" /><published>2025-03-01T00:00:00+00:00</published><updated>2025-03-01T00:00:00+00:00</updated><id>https://ccolombe12.github.io/blog/2025/fiddler</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2025/fiddler/"><![CDATA[<p>I found a new source of puzzles: the excellent Substack page <a href="https://thefiddler.substack.com">The Fiddler on the Proof</a> run by Zach Wissner-Gross. This week’s puzzle is paraphrased as follows:</p>

<blockquote>
  <p>Suppose I have a hat with \(3n\) small toy rabbits: \(n\) are red, \(n\) are green, and \(n\) are blue. I shuffle the rabbits around and randomly draw them out one at a time without replacement (i.e., once I draw a rabbit out, I never put it back in again).</p>

  <p>Your job is to guess the color of each rabbit I draw. For each guess, you know the history of the rabbits already drawn. So if we’re down to the final rabbit in the hat, you should be able to predict its color with certainty.</p>

  <p>Every time you correctly predict the color of the rabbit I draw, you earn a point. If you play optimally (i.e., to maximize your expected points), <strong>how many points can you expect to earn on average?</strong></p>
</blockquote>

<h2 id="solution">Solution</h2>

<p>We can solve this using <a href="https://en.wikipedia.org/wiki/Dynamic_programming">Dynamic Programming</a>! We represent the current state as a tuple \((r, g, b)\), where \(r, g,\) and \(b\) denote the number of rabbits of each color remaining in the hat. Let \(J(r, g, b)\) be the maximum expected score starting from state \((r, g, b)\). Our goal is to determine \(J(n, n, n)\). We can solve for \(J(n, n, n)\) by developing a <strong>recurrence relation</strong> on the current state. We begin with the base cases.</p>

<h3 id="base-cases">Base Cases</h3>

<ul>
  <li>If there are no rabbits left, i.e., we are at state \((0, 0, 0)\), then there are zero points left to obtain, implying
\(J(0, 0, 0) = 0.\)</li>
  <li>If any of \(r, g,\) or \(b\) are negative, we define:
\(J\left(r, g, b \right) = 0, \; \text{if any } r &lt; 0, g &lt; 0, \text{or } b &lt; 0.\)
While negative rabbit counts don’t have any physical interpretation, this condition will allow us to greatly simplify our recurrence relation.</li>
</ul>

<h3 id="recurrence-relation">Recurrence Relation</h3>

<p>For a general state where \(r, g, b \geq 0\) and at <em>least one of them is positive</em>, we can determine the expected points-maximizing guess for the next rabbit’s color by considering each option and selecting the best one. The probabilities for the next color of rabbit drawn are:</p>

<ul>
  <li>The probability of drawing a red rabbit \(P_r = \frac{r}{r + g + b}\).</li>
  <li>The probability of drawing a green rabbit \(P_g = \frac{g}{r + g + b}\).</li>
  <li>The probability of drawing a blue rabbit \(P_b = \frac{b}{r + g + b}\).</li>
</ul>

<p>Given these, the expected scores from guessing each color are:</p>

<p>\(J\left(r, g, b \mid \text{guess red}\right) = P_r \cdot (1 + J(r - 1, g, b)) + P_g\cdot J(r, g - 1, b) + P_b\cdot J(r, g, b - 1),\)
\(J\left(r, g, b \mid \text{guess green}\right) = P_r\cdot J(r - 1, g, b) + P_g\cdot (1 + J(r, g - 1, b)) + P_b\cdot J(r, g, b - 1),\)
\(J \left(r, g, b \mid \text{guess blue}\right) = P_r\cdot J(r - 1, g, b) + P_g\cdot J(r, g - 1, b) + P_b\cdot (1 + J(r, g, b - 1)).\)</p>

<p>To find the optimal expected score at state \((r, g, b)\), we take the maximum over these three choices.</p>

\[\boxed{J\left(r, g, b\right) = \max \left\{ J\left(r, g, b \mid \text{guess red}\right), J\left(r, g, b \mid \text{guess green}\right), J\left(r, g, b \mid \text{guess blue}\right) \right\}}.\]

<p>The optimal guess is the color that achieves this maximum.</p>

<h3 id="implementation">Implementation</h3>

<p>Now that we have a recursive formulation, we can efficiently compute \(J(r, g, b)\) using dynamic programming. Let’s code this up in Python<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>!</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">functools</span> <span class="kn">import</span> <span class="n">cache</span>

<span class="nd">@cache</span>
<span class="k">def</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="sh">"""</span><span class="s"> Returns the maximum expected score under optimal play from the state
(r, g, b) </span><span class="sh">"""</span>
    <span class="c1"># Base Cases
</span>    <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">g</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">g</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="c1"># Main recurrence Case 
</span>    <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">g</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">total_rabbits</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">g</span> <span class="o">+</span> <span class="n">b</span>
        <span class="n">Pr</span><span class="p">,</span> <span class="n">Pb</span><span class="p">,</span> <span class="n">Pg</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">total_rabbits</span><span class="p">,</span> <span class="n">b</span> <span class="o">/</span> <span class="n">total_rabbits</span><span class="p">,</span> <span class="n">g</span> <span class="o">/</span> <span class="n">total_rabbits</span>
        
        <span class="n">guess_red</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pr</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="o">+</span>  
            <span class="n">Pg</span> <span class="o">*</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">+</span>
            <span class="n">Pb</span> <span class="o">*</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        
        <span class="n">guess_green</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pg</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="o">+</span>
            <span class="n">Pr</span> <span class="o">*</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">+</span>
            <span class="n">Pb</span> <span class="o">*</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                       
        <span class="n">guess_blue</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pb</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span>
            <span class="n">Pr</span> <span class="o">*</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">+</span>
            <span class="n">Pg</span> <span class="o">*</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="nf">max</span><span class="p">(</span><span class="n">guess_green</span><span class="p">,</span> <span class="n">guess_red</span><span class="p">,</span> <span class="n">guess_blue</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">optimal_score</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="sh">"""</span><span class="s"> The value of J(n, n n) and the answer to our puzzle. </span><span class="sh">"""</span>
    <span class="k">return</span> <span class="nf">max_points</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</code></pre></div></div>

<p>Now, if we plot the value of \(J(n, n, n)\) as a function of \(n\), we obtain Figure 1. Here we see that under the optimal guessing strategy, the expected score seems to grow roughly like \(\sim \frac{n}{3}\). In fact, we can actually note that \(\frac{n}{3}\) is a lower bound on the optimal expected score because it can be <em>obtained with certainty</em> by choosing one color of rabbit and guessing that color each turn until the game ends. We call this naive strategy the “stubborn guessing” strategy (since you refuse to change your guess each turn).</p>

<figure>
    <img src="/assets/img/blog_images/2025-02-28-rabbits/optimal_rabbits.png" alt="Max Rabbits Optimal Score" width="80%" style="display: block; margin: auto;" />
    <figcaption style="text-align: center;">Figure 1: Maximum number of points possible with optimal rabbit selection.</figcaption>
</figure>

<p>We can see that our optimal strategy does outperform the stubborn guessing strategy, but not by too much!</p>

<p>Okay, we have found a way to compute the expected number of points we can score under the optimal guessing strategy, but <strong>what actually is the optimal guessing strategy?</strong>. By recording the optimal guess at each step in our recursion, we can observe the optimal strategy has a simple form:</p>

<blockquote>
  <p><em>At any given state, guess a color that has the most rabbits remaining in the hat</em>.</p>
</blockquote>

<p>This makes sense intuitively, and this simple rule provides us with the best heuristic for maximizing our expected score.</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1">
      <p>Instead of building the DP table explicitly, we use the <code class="language-plaintext highlighter-rouge">cache</code> tool from the <code class="language-plaintext highlighter-rouge">functools</code> library. It’s one of my favorite Python tools! <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name>Connor Colombe</name></author><category term="programming," /><category term="math" /><summary type="html"><![CDATA[My solution to this week's Fiddler on the Proof Puzzle]]></summary></entry><entry><title type="html">Leetcode Milestone</title><link href="https://ccolombe12.github.io/blog/2024/CP_intro/" rel="alternate" type="text/html" title="Leetcode Milestone" /><published>2024-06-17T00:00:01+00:00</published><updated>2024-06-17T00:00:01+00:00</updated><id>https://ccolombe12.github.io/blog/2024/CP_intro</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2024/CP_intro/"><![CDATA[<h2 id="my-journey-to-start-competitive-programming">My journey to start competitive programming</h2>

<p>It’s no secret that I love to think about and work on math/programming puzzles. Over the past several months I have decided to begin a new hobby: Competitive programming! Not only will this keep me sharp for my upcoming job search post grad school, but it is a great way to continue to bolster my problem solving skills and keep fresh the algorithm design skills that I learned during my time at UTD.</p>

<p>My favorite resources for finding problems to work on are: <a href="https://leetcode.com/">Leetcode</a> (a very popular site for interview style programming problems), <a href="https://open.kattis.com/">Kattis</a> (an online problem archive of problems that have been asked in programming contests around the world), and <a href="https://codeforces.com/">Codeforces</a> (another very popular website that hosts high-quality contests). I have been regularly competing in the weekly Leetcode contests and learning a lot in doing so! I plan to reach around 500 problems in Leetcode and achieve a 1900+ rating and then switch to Codeforces since I have heard the problems are more interesting and more mathematical (woo!). I recently broke into the  “knight” level in the Leetcode contests which is currently for those  the top ~ 6% in overall contest performance! You can check out my current contest rating and activity <a href="https://leetcode.com/u/ccolombe12">here</a>!</p>

<h3><figure>
  <center>
  <img src="/assets/img/blog_images/LC_post/LC_Knight.png" width="80%" style="display: block; margin: auto;" />
  </center>

</figure></h3>]]></content><author><name>Connor Colombe</name></author><category term="programming" /><summary type="html"><![CDATA[My journey to start competitive programming]]></summary></entry><entry><title type="html">Jane Street Puzzle August 2024</title><link href="https://ccolombe12.github.io/blog/2024/JS_tree/" rel="alternate" type="text/html" title="Jane Street Puzzle August 2024" /><published>2024-06-17T00:00:01+00:00</published><updated>2024-06-17T00:00:01+00:00</updated><id>https://ccolombe12.github.io/blog/2024/JS_tree</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2024/JS_tree/"><![CDATA[<h1 id="tree-edge-triage">Tree-Edge Triage</h1>

<p>It has become a hobby of mine to work on the monthly <a href="https://www.janestreet.com/puzzles/current-puzzle/">Jane Street Puzzle</a>. They usually pose some interesting math or programming problem and I have learned a lot from solving them. Last month’s puzzle was a game played on an infinite binary tree with a surprising result! The problem is as follows:</p>

<h1 id="problem-statement">Problem Statement</h1>
<blockquote>
  <p>Aaron and Beren are playing a game on an infinite complete binary tree. At the beginning of the game, every edge of the tree is independently labeled \(A\) with probability \(p\) and \(B\) otherwise. Both players are able to inspect all of these labels. Then, starting with Aaron at the root of the tree, the players alternate turns moving a shared token down the tree (each turn the active player selects from the two descendants of the current node and moves the token along the edge to that node). If the token ever traverses an edge labeled B, Beren wins the game. Otherwise, Aaron wins.</p>

  <p>An example game is in the picture below: after the labeling, Aaron chooses to go left to avoid immediate defeat, but after Beren goes right Aaron is doomed to choose one of two B paths and Beren wins.</p>

  <p><strong>What is the infimum of the set of all probabilities \(p\) for which Aaron has a nonzero probability of winning the game?</strong> Give your answer in exact terms.</p>
</blockquote>

<h3><figure>
  <center>
  <img src="/assets/img/blog_images/JS_Aug_24/ps.png" style="width: 40vw; min-width: 330px;" zoomable="true" />
  </center>
</figure></h3>
<h1 id="solution">Solution</h1>

<p>The intuition behind my approach was to use the <strong>symmetry</strong> of an infinite binary tree. Once you move along an edge to a given node, you are once again faced with an infinite binary tree and <em>it’s like you started from the beginning again</em>. By that logic, it is sufficient to analyze the optimal strategy for the first two levels and we can let recursion handle the rest.</p>

<p>Suppose we are considering what Aaron should do on a given turn. On every \(A\) (odd) turn, Aaron wins if and only if the current node has at least one \(A\) edge out of it that leads to a node with two \(A\) edges and each of these edges has a winning \(A\) path out of it.</p>

<p>We can write this using a recurrence relation. Let \(Q_A\) be the probability that, on an \(A\) turn, \(A\) can win from the current node from it. Similarly, let \(Q_B\) be the probability that at our current node on a \(B\) turn, it is one from which \(A\) <em>will</em> win.</p>

<p>Using this notation, we can develop our recurrence relation as:</p>

\[\begin{align}
Q_A &amp; = p^2(\underbrace{Q_B^2 + 2Q_B(1-Q_B)}_{\text{Pr at least one winning path out}}) + 2p(1-p)Q_B \\
Q_B &amp; = p^2 Q_A^2.
\end{align}\]

<p>The fist equation represents the cases where we are on Aaron’s turn and either:</p>

<ul>
  <li>both of the edges out of our current node are labeled \(A\) and Aaron can win from at least one of the children nodes</li>
  <li>There is only one \(A\) edge out of the current node and Aaron can win from the node it leads to.</li>
</ul>

<p>The second equation represents the case where we are on Beren’s turn and:</p>

<ul>
  <li>Both of the edges out of the current node are labeled \(A\) and lead to nodes at which Aaron wins.</li>
</ul>

<p>Plugging in the latter equation into the former yields the equation for \(Q_A\) in terms of \(p\)</p>

<p>\begin{equation}
Q_A = 2p^4 Q_A^2 - p^6 Q_A^4 + 2p^3(1-p)Q_A^2 \implies   \boxed{Q_A(-p^6 Q_A^3 + 2p^3Q_A - 1) = 0} 
\end{equation}</p>

<p>Now if we want to find the values of \(p\) for which there is a non-negative value for \(Q_A\) (the probability of Aaron winning the game from the first move), then we need to find the smallest value of \(p\) for which</p>

<p>\begin{equation}p^6 Q_A^3 - 2p^3Q_A + 1 = 0 \label{eq:QA_zero}\end{equation}</p>

<p>has a positive solution when we solve for \(Q_A\).</p>

<p>Note that (\ref{eq:QA_zero}) is a <em>cubic equation</em> in \(Q_A\) and thus will always have a real root. But, we need \(Q_A\) to be in the range \([0,1]\). The values of \(Q_A\) satisfying the above (\ref{eq:QA_zero}) for a fixed value of \(p\) are:</p>

<p><small>
\(\begin{align}
r_1 &amp; = \frac{4 \sqrt[3]{3} p^9+\sqrt[3]{2} \left(\sqrt{81 p^{24}-96 p^{27}}-9 p^{12}\right)^{2/3}}{6^{2/3} p^6 \sqrt[3]{\sqrt{81 p^{24}-96 p^{27}}-9 p^{12}}}\\
r_2 &amp; = -\frac{4 \sqrt[3]{3} p^9+\sqrt[3]{2} \left(\sqrt{81 p^{24}-96 p^{27}}-9 p^{12}\right)^{2/3}}{2\ 6^{2/3} p^6 \sqrt[3]{\sqrt{81 p^{24}-96 p^{27}}-9 p^{12}}} + i \left(\frac{ \left(3^{5/6} \left(2 \sqrt{81 p^{24}-96 p^{27}}-18 p^{12}\right)^{2/3}-12 \sqrt[3]{2} \sqrt[6]{3} p^9\right)}{12 p^6 \sqrt[3]{\sqrt{81 p^{24}-96 p^{27}}-9 p^{12}}}\right)\\
r_3 &amp; = \overline{r_2}
\end{align}\)
</small></p>

<p>The keen eye may notice that these are <em>gross</em> looking equations. As mentioned before, since our equation was cubic in \(Q_A\), one of these is guaranteed to be real. The other two are either both real or both complex. What do we see when we plot these out as a function of \(p\)?</p>

<h3><figure>
  <center>
  <img src="/assets/img/blog_images/JS_Aug_24/prob_plot.png" width="80%" style="display: block; margin: auto;" />
</center>
</figure></h3>

<p>We see that for \(p \leq\frac{3}{2^{5/3}} \approx  0.94\), there is only <em>one real root and it is negative</em>. However, for \(\boxed{p &gt; \frac{3}{2^{5/3}}}\), the <em>roots are all real with two positive and one negative</em>. This value of \(p\) comes from setting \(p\) to ensure that the term \(\sqrt{81 p^{24}-96 p^{27}}\) (which appears in each of the expressions for the roots), is real. Does this produce a valid probability value for \(Q_A\)?</p>

<p>For \(p\) just above this threshold value of \(\hat{p} = \frac{3}{2^{5/3}}\), we see \(Q_A\) has near repeated roots of around \(\approx 0.88\), validating our solution. Interestingly \(Q_A\) is <strong>zero</strong> until \(p &gt; \hat{p}\) at which it instantaneously jumps up to around \(Q_A \approx 0.88\), as seen in the plot above!</p>]]></content><author><name>Connor Colombe</name></author><category term="programming" /><summary type="html"><![CDATA[My solution to last month's puzzle]]></summary></entry><entry><title type="html">Jane Street March 2024 Puzzle Solution</title><link href="https://ccolombe12.github.io/blog/2024/JS_Hooks10/" rel="alternate" type="text/html" title="Jane Street March 2024 Puzzle Solution" /><published>2024-04-01T00:00:01+00:00</published><updated>2024-04-01T00:00:01+00:00</updated><id>https://ccolombe12.github.io/blog/2024/JS_Hooks10</id><content type="html" xml:base="https://ccolombe12.github.io/blog/2024/JS_Hooks10/"><![CDATA[<style type="text/css">
    ol { list-style-type: lower-alpha; }
</style>

<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<h2 id="jane-street-hooks-10">Jane Street: Hooks 10</h2>

<p>My solution to the March 2024 month <a href="https://www.janestreet.com/puzzles/hooks-10-index/">Jane Street Puzzle: Hooks 10</a>.</p>

<p>The problem boils down to finding a feasible arrangement of hooks and cells for the given constraints. Luckily for me and my operations research background, this can essentially be represented as a large integer program (IP)! I saw this was the 10’th iteration of the Hooks puzzles and found (<a href="https://github.com/gowen100/Jane-Street-Solutions">Gowen100’s</a>) IP approach to the previous Hooks puzzle. This was a great opportunity to learn a new tool: The <a href="https://www.microsoft.com/en-us/research/project/z3-3/">Z3 theorem prover </a> from Microsoft research. I was able to use what I learned to create the necessary augmentations to solve the newest iteration of the the hooks puzzle! Looking forward to solving the future puzzles with this new tool!</p>

<iframe src="/assets/Jane_Street_Mar_2024.html" width="125%" height="900"></iframe>]]></content><author><name>Connor Colombe</name></author><category term="math" /><summary type="html"><![CDATA[]]></summary></entry></feed>